<*
 SDL offers cross-platform thread management functions. These are mostly
 concerned with starting threads, setting their priority, and dealing with
 their termination.

 In addition, there is support for Thread Local Storage (data that is unique
 to each thread, but accessed from a single key).

 On platforms without thread support (such as Emscripten when built without
 pthreads), these functions still exist, but things like SDL_CreateThread()
 will report failure without doing anything.

 If you're going to work with threads, you almost certainly need to have a
 good understanding of [CategoryMutex](CategoryMutex) as well.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryThread
*>
module sdl;

<*
 The SDL thread object.
 This datatype is available since SDL 3.2.0.

 These are opaque data.
*>
typedef SDLThread = void;

<*
 A unique numeric ID that identifies a thread.
 This datatype is available since SDL 3.2.0.

 These are different from SDL_Thread objects, which are generally what an
 application will operate on, but having a way to uniquely identify a thread
 can be useful at times.
*>
typedef SDLThreadID = ulong;

<*
 Thread local storage ID.
 This datatype is available since SDL 3.2.0.

 0 is the invalid ID. An app can create these and then set data for these
 IDs that is unique to each thread.
*>
typedef TlsId = SDLAtomicInt;

<*
 The SDL thread priority.
 This enum is available since SDL 3.2.0.

 SDL will make system changes as necessary in order to apply the thread
 priority. Code which attempts to control thread state related to priority
 should be aware that calling SDL_SetCurrentThreadPriority may alter such
 state. SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of
 this behavior.
*>
enum SDLThreadPriority 
{
    LOW,
    NORMAL,
    HIGH,
    TIME_CRITICAL
}

<*
 The SDL thread state.
 This enum is available since SDL 3.2.0.

 The current state of a thread can be checked by calling SDL_GetThreadState.
*>
enum SDLThreadState
{
    UNKNOWN,     // The thread is not valid
    ALIVE,       // The thread is currently running
    DETACHED,    // The thread is detached and can't be waited on
    COMPLETE     // The thread has finished and should be cleaned up with SDL_WaitThread()
}

<*
 The function passed to SDL_CreateThread() as the new thread's entry point.
 This datatype is available since SDL 3.2.0.

 @param data : `what was passed as 'data' to SDL_CreateThread().`
 @return `a value that can be reported through SDL_WaitThread().`
*>
alias SDLThreadFunction = fn CInt(void* data);

<*
 Create a new thread with a default stack size.
 This function is available since SDL 3.2.0.

 This is a convenience function, equivalent to calling
 SDL_CreateThreadWithProperties with the following properties set:

 - `SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER`: `fn`
 - `SDL_PROP_THREAD_CREATE_NAME_STRING`: `name`
 - `SDL_PROP_THREAD_CREATE_USERDATA_POINTER`: `data`

 Note that this "function" is actually a macro that calls an internal
 function with two extra parameters not listed here; they are hidden through
 preprocessor macros and are needed to support various C runtimes at the
 point of the function call. Language bindings that aren't using the C
 headers will need to deal with this.

 Usually, apps should just call this function the same way on every platform
 and let the macros hide the details.

 @param func : `the SDL_ThreadFunction function to call in the new thread.`
 @param name : `the name of the thread.`
 @param data : `a pointer that is passed to 'func'.`
 @return `an opaque pointer to the new thread object on success, NULL if the
          new thread could not be created; call SDL_GetError() for more
          information.`
*>
macro SDLThread* create_thread(SDLThreadFunction func, ZString name, void* data)
{
	$if env::WIN32:
		return create_thread_runtime(func, name, data, _beginthreadex, _endthreadex);
	$else
		return create_thread_runtime(func, name, data, NULL, NULL);
	$endif
}

<*
 Create a new thread with with the specified properties.
 This function is available since SDL 3.2.0.

 These are the supported properties:

 - `SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER`: an SDL_ThreadFunction
   value that will be called at the start of the new thread's life.
   Required.
 - `SDL_PROP_THREAD_CREATE_NAME_STRING`: the name of the new thread, which
   might be available to debuggers. Optional, defaults to NULL.
 - `SDL_PROP_THREAD_CREATE_USERDATA_POINTER`: an arbitrary app-defined
   pointer, which is passed to the entry function on the new thread, as its
   only parameter. Optional, defaults to NULL.
 - `SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER`: the size, in bytes, of the new
   thread's stack. Optional, defaults to 0 (system-defined default).

 SDL makes an attempt to report `SDL_PROP_THREAD_CREATE_NAME_STRING` to the
 system, so that debuggers can display it. Not all platforms support this.

 Thread naming is a little complicated: Most systems have very small limits
 for the string length (Haiku has 32 bytes, Linux currently has 16, Visual
 C++ 6.0 has _nine_!), and possibly other arbitrary rules. You'll have to
 see what happens with your system's debugger. The name should be UTF-8 (but
 using the naming limits of C identifiers is a better bet). There are no
 requirements for thread naming conventions, so long as the string is
 null-terminated UTF-8, but these guidelines are helpful in choosing a name:

 https://stackoverflow.com/questions/149932/naming-conventions-for-threads

 If a system imposes requirements, SDL will try to munge the string for it
 (truncate, etc), but the original string contents will be available from
 SDL_GetThreadName().

 The size (in bytes) of the new stack can be specified with
 `SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER`. Zero means "use the system
 default" which might be wildly different between platforms. x86 Linux
 generally defaults to eight megabytes, an embedded device might be a few
 kilobytes instead. You generally need to specify a stack that is a multiple
 of the system's page size (in many cases, this is 4 kilobytes, but check
 your system documentation).

 Note that this "function" is actually a macro that calls an internal
 function with two extra parameters not listed here; they are hidden through
 preprocessor macros and are needed to support various C runtimes at the
 point of the function call. Language bindings that aren't using the C
 headers will need to deal with this.

 The actual symbol in SDL is `SDL_CreateThreadWithPropertiesRuntime`, so
 there is no symbol clash, but trying to load an SDL shared library and look
 for "SDL_CreateThreadWithProperties" will fail.

 Usually, apps should just call this function the same way on every platform
 and let the macros hide the details.

 @param props : `the properties to use.`
 @return `an opaque pointer to the new thread object on success, NULL if the
          new thread could not be created; call SDL_GetError() for more
          information.`
*>
macro SDLThread* create_thread_with_properties(SDLPropertiesID props)
{
	$if env::WIN32:
		return create_thread_with_properties_runtime(props, _beginthreadex, _endthreadex);
	$else
		return create_thread_with_properties_runtime(props, NULL, NULL);
	$endif
}

enum SDLPropThreadCreate : const inline ZString
{
	ENTRY_FUNCTION_POINTER  = "SDL.thread.create.entry_function",
	NAME_STRING             = "SDL.thread.create.name",
	USERDATA_POINTER        = "SDL.thread.create.userdata",
	STACKSIZE_NUMBER        = "SDL.thread.create.stacksize",
}

/* These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! */
<*
 The actual entry point for SDL_CreateThread.
 This function is available since SDL 3.2.0.

 @param func : `the SDL_ThreadFunction function to call in the new thread`
 @param name : `the name of the thread`
 @param data : `a pointer that is passed to 'func'`
 @param pfn_begin_thread : `the C runtime's _beginthreadex (or whatnot). Can be NULL.`
 @param pfn_end_thread : `the C runtime's _endthreadex (or whatnot). Can be NULL.`
 @return `an opaque pointer to the new thread object on success, NULL if the
          new thread could not be created; call SDL_GetError() for more
          information.`
*>
extern fn SDLThread* create_thread_runtime(SDLThreadFunction func, ZString name, void* data, SDLFunctionPointer pfn_begin_thread, SDLFunctionPointer pfn_end_thread) @extern("SDL_CreateThreadRuntime") @local;

<*
 The actual entry point for SDL_CreateThreadWithProperties.
 This function is available since SDL 3.2.0.

 @param props : `the properties to use`
 @param pfn_begin_thread : `the C runtime's _beginthreadex (or whatnot). Can be NULL.`
 @param pfn_end_thread : `the C runtime's _endthreadex (or whatnot). Can be NULL.`
 @return `an opaque pointer to the new thread object on success, NULL if the
          new thread could not be created; call SDL_GetError() for more
          information.`
*>
extern fn SDLThread* create_thread_with_properties_runtime(SDLPropertiesID props, SDLFunctionPointer pfn_begin_thread, SDLFunctionPointer pfn_end_thread) @extern("SDL_CreateThreadWithPropertiesRuntime") @local;

<*
 Get the thread name as it was specified in SDL_CreateThread().
 This function is available since SDL 3.2.0.

 @param thread : `the thread to query.`
 @return `a pointer to a UTF-8 string that names the specified thread, or
          NULL if it doesn't have a name.`
*>
extern fn ZString SDLThread.get_name(&thread) @extern("SDL_GetThreadName");

<*
 Get the thread identifier for the current thread.
 This function is available since SDL 3.2.0.

 This thread identifier is as reported by the underlying operating system.
 If SDL is running on a platform that does not support threads the return
 value will always be zero.

 This function also returns a valid thread ID when called from the main
 thread.

 @return `the ID of the current thread.`
*>
extern fn SDLThreadID get_current_thread_id() @extern("SDL_GetCurrentThreadID");

<*
 Get the thread identifier for the specified thread.
 This function is available since SDL 3.2.0.

 This thread identifier is as reported by the underlying operating system.
 If SDL is running on a platform that does not support threads the return
 value will always be zero.

 @param thread : `the thread to query.`
 @return `the ID of the specified thread, or the ID of the current thread if
          'thread' is NULL.`
*>
extern fn SDLThreadID SDLThread.get_id(&thread) @extern("SDL_GetThreadID");

<*
 Set the priority for the current thread.
 This function is available since SDL 3.2.0.

 Note that some platforms will not let you alter the priority (or at least,
 promote the thread to a higher priority) at all, and some require you to be
 an administrator account. Be prepared for this to fail.

 @param priority : `the SDL_ThreadPriority to set.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool set_current_thread_priority(SDLThreadPriority priority) @extern("SDL_SetCurrentThreadPriority");

<*
 Wait for a thread to finish.
 This function is available since SDL 3.2.0.

 Threads that haven't been detached will remain until this function cleans
 them up. Not doing so is a resource leak.

 Once a thread has been cleaned up through this function, the SDL_Thread
 that references it becomes invalid and should not be referenced again. As
 such, only one thread may call SDL_WaitThread() on another.

 The return code from the thread function is placed in the area pointed to
 by `status`, if `status` is not NULL.

 You may not wait on a thread that has been used in a call to
 SDL_DetachThread(). Use either that function or this one, but not both, or
 behavior is undefined.

 It is safe to pass a NULL thread to this function; it is a no-op.

 Note that the thread pointer is freed by this function and is not valid
 afterward.

 @param thread : `the SDL_Thread pointer that was returned from the
                  SDL_CreateThread() call that started this thread.`
 @param status : `a pointer filled in with the value returned from the thread
               function by its 'return', or -1 if the thread has been
               detached or isn't valid, may be NULL.`
*>
extern fn void SDLThread.wait(&thread, int* status) @extern("SDL_WaitThread");

<*
 Get the current state of a thread.
 This function is available since SDL 3.2.0.

 @param thread : `the thread to query.`
 @return `the current state of a thread, or SDL_THREAD_UNKNOWN if the thread
          isn't valid.`
*>
extern fn SDLThreadState SDLThread.get_state(&thread) @extern("SDL_GetThreadState");

<*
 Let a thread clean up on exit without intervention.
 This function is available since SDL 3.2.0.

 A thread may be "detached" to signify that it should not remain until
 another thread has called SDL_WaitThread() on it. Detaching a thread is
 useful for long-running threads that nothing needs to synchronize with or
 further manage. When a detached thread is done, it simply goes away.

 There is no way to recover the return code of a detached thread. If you
 need this, don't detach the thread and instead use SDL_WaitThread().

 Once a thread is detached, you should usually assume the SDL_Thread isn't
 safe to reference again, as it will become invalid immediately upon the
 detached thread's exit, instead of remaining until someone has called
 SDL_WaitThread() to finally clean it up. As such, don't detach the same
 thread more than once.

 If a thread has already exited when passed to SDL_DetachThread(), it will
 stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
 not safe to detach a thread that might be used with SDL_WaitThread().

 You may not call SDL_WaitThread() on a thread that has been detached. Use
 either that function or this one, but not both, or behavior is undefined.

 It is safe to pass NULL to this function; it is a no-op.

 @param thread : `the SDL_Thread pointer that was returned from the
               SDL_CreateThread() call that started this thread.`
*>
extern fn void SDLThread.detach(&thread) @extern("SDL_DetachThread");

<*
 Get the current thread's value associated with a thread local storage ID.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param id : `a pointer to the thread local storage ID, may not be NULL.`
 @return `the value associated with the ID for the current thread or NULL if
          no value has been set; call SDL_GetError() for more information.`
*>
extern fn void* TlsId.get(&id) @extern("SDL_GetTLS");

<*
 The callback used to cleanup data passed to SDL_SetTLS.
 This datatype is available since SDL 3.2.0.

 This is called when a thread exits, to allow an app to free any resources.

 @param value : `a pointer previously handed to SDL_SetTLS.`
*>
alias SDLTLSDestructorCallback = fn void(void* value);

<*
 Set the current thread's value associated with a thread local storage ID.
 This function is available since SDL 3.2.0.

 If the thread local storage ID is not initialized (the value is 0), a new
 ID will be created in a thread-safe way, so all calls using a pointer to
 the same ID will refer to the same local storage.

 Note that replacing a value from a previous call to this function on the
 same thread does _not_ call the previous value's destructor!

 `destructor` can be NULL; it is assumed that `value` does not need to be
 cleaned up if so.

 threadsafety: It is safe to call this function from any thread.

 @param id : `a pointer to the thread local storage ID, may not be NULL.`
 @param value : `the value to associate with the ID for the current thread.`
 @param destructor : `a function called when the thread exits, to free the
                      value, may be NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool TlsId.set(&id, void* value, SDLTLSDestructorCallback destructor) @extern("SDL_SetTLS");

<*
 Cleanup all TLS data for this thread.
 This function is available since SDL 3.2.0.

 If you are creating your threads outside of SDL and then calling SDL
 functions, you should call this function before your thread exits, to
 properly clean up SDL memory.

 threadsafety: It is safe to call this function from any thread.
*>
extern fn void cleanup_tls() @extern("SDL_CleanupTLS");
