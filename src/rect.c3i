<*
 Some helper functions for managing rectangles and 2D points, in both
 integer and floating point versions.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryRect
*>
module sdl;

import std::math;

<*
 The structure that defines a point (using integers).
 This struct is available since SDL 3.2.0.
*>
struct SDLPoint
{
    CInt x;
    CInt y;
}

<*
 The structure that defines a point (using floating point values).
 This struct is available since SDL 3.2.0.
*>
struct SDLFPoint
{
    float x;
    float y;
}


<*
 A rectangle, with the origin at the upper left (using integers).
 This struct is available since SDL 3.2.0.
*>
struct SDLRect
{
    CInt x, y;
    CInt w, h;
}


<*
 A rectangle, with the origin at the upper left (using floating point
 values).
 This struct is available since SDL 3.2.0.
*>
struct SDLFRect
{
    float x;
    float y;
    float w;
    float h;
}


<*
 Convert an SDL_Rect to SDL_FRect
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param rect :  `a pointer to an SDL_Rect.`
 @param frect : `a pointer filled in with the floating point representation of
                'rect'.`
*>
macro SDLRect.to_frect(SDLRect* rect, SDLFRect* frect) {
    frect.x = rect.x;
    frect.y = rect.y;
    frect.w = rect.w;
    frect.h = rect.h;
}

<*
 Determine whether a point resides inside a rectangle.
 This function is available since SDL 3.2.0.

 A point is considered part of a rectangle if both `p` and `r` are not NULL,
 and `p`'s x and y coordinates are >= to the rectangle's top left corner,
 and < the rectangle's x+w and y+h. So a 1x1 rectangle considers point (0,0)
 as "inside" and (0,1) as not.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param p : `the point to test.`
 @param r : `the rectangle to test.`
 @return `true if 'p' is contained by 'r', false otherwise.`
*>
macro bool SDLPoint.in_rect(&p, SDLRect* r) => (
    (
        p && r &&
        (p.x >= r.x) && (p.x < (r.x + r.w)) &&
        (p.y >= r.y) && (p.y < (r.y + r.w))
    ) ? true : false
);

<*
 Determine whether a rectangle has no area.
 This function is available since SDL 3.2.0.

 A rectangle is considered "empty" for this function if `r` is NULL, or if
 `r`'s width and/or height are <= 0.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param r : `the rectangle to test.`
 @return `true if the rectangle is "empty", false otherwise.`
*>
macro bool SDLRect.empty(&r) => (
    ((!r) || (r.w <= 0) || (r.h <= 0)) ? true : false
);

<*
 Determine whether two rectangles are equal.
 This function is available since SDL 3.2.0.

 Rectangles are considered equal if both are not NULL and each of their x,
 y, width and height match.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param a : `the first rectangle to test.`
 @param b : `the second rectangle to test.`
 @return `true if the rectangles are equal, false otherwise.`
*>
macro bool SDLRect.equal(&a, SDLRect* b) => (
    (
        a && b && 
        (a.x == b.x) && (a.y == b.y) &&
        (a.w == b.w) && (a.h == b.h)
    ) ? true : false
);

<*
 Determine whether two rectangles intersect.
 This function is available since SDL 3.2.0.

 If either pointer is NULL the function will return false.

 threadsafety: It is safe to call this function from any thread.

 @param a : `an SDL_Rect structure representing the first rectangle.`
 @param b : `an SDL_Rect structure representing the second rectangle.`
 @return `true if there is an intersection, false otherwise.`
*>
extern fn bool SDLRect.has_intersection(&a, SDLRect* b) @extern("SDL_HasRectIntersection");

<*
 Calculate the intersection of two rectangles.
 This function is available since SDL 3.2.0.

 If `result` is NULL then this function will return false.

 @param a : `an SDL_Rect structure representing the first rectangle.`
 @param b : `an SDL_Rect structure representing the second rectangle.`
 @param result : `an SDL_Rect structure filled in with the intersection of
               rectangles 'a' and 'b'.`
 @return `true if there is an intersection, false otherwise.`
*>
extern fn bool SDLRect.get_intersection(&a, SDLRect* b, SDLRect* result) @extern("SDL_GetRectIntersection");

<*
 Calculate the union of two rectangles.
 This function is available since SDL 3.2.0.

 @param a : `an SDL_Rect structure representing the first rectangle.`
 @param b : `an SDL_Rect structure representing the second rectangle.`
 @param result : `an SDL_Rect structure filled in with the union of rectangles
               'a' and 'b'.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRect.get_union(&a, SDLRect* b, SDLRect* result) @extern("SDL_GetRectUnion");

<*
 Calculate a minimal rectangle enclosing a set of points.

 If `clip` is not NULL then only points inside of the clipping rectangle are
 considered.

 @param points : `an array of SDL_Point structures representing points to be
                  enclosed.`
 @param count : `the number of structures in the 'points' array.`
 @param clip : `an SDL_Rect used for clipping or NULL to enclose all points.`
 @param result : `an SDL_Rect structure filled in with the minimal enclosing
                  rectangle.`
 @return `true if any points were enclosed or false if all the points were
          outside of the clipping rectangle.`
*>
extern fn bool get_rect_enclosing_points(SDLPoint* points, CInt count, SDLRect* clip, SDLRect* result) @extern("SDL_GetRectEnclosingPoints");

<*
 Calculate the intersection of a rectangle and line segment.
 This function is available since SDL 3.2.0.

 This function is used to clip a line segment to a rectangle. A line segment
 contained entirely within the rectangle or that does not intersect will
 remain unchanged. A line segment that crosses the rectangle at either or
 both ends will be clipped to the boundary of the rectangle and the new
 coordinates saved in `x1`, `y1`, `x2`, and/or `y2` as necessary.

 @param rect : `an SDL_Rect structure representing the rectangle to intersect.`
 @param x1 : `a pointer to the starting X-coordinate of the line.`
 @param y1 : `a pointer to the starting Y-coordinate of the line.`
 @param x2 : `a pointer to the ending X-coordinate of the line.`
 @param y2 : `a pointer to the ending Y-coordinate of the line.`
 @return `true if there is an intersection, false otherwise.`
*>
extern fn bool SDLRect.get_line_intersection(&rect, CInt* x1, CInt* y1, CInt* x2, CInt* y2) @extern("SDL_GetRectAndLineIntersection");


/* SDL_FRect versions... */

<*
 Determine whether a point resides inside a floating point rectangle.
 This function is available since SDL 3.2.0.

 A point is considered part of a rectangle if both `p` and `r` are not NULL,
 and `p`'s x and y coordinates are >= to the rectangle's top left corner,
 and <= the rectangle's x+w and y+h. So a 1x1 rectangle considers point
 (0,0) and (0,1) as "inside" and (0,2) as not.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param p : `the point to test.`
 @param r : `the rectangle to test.`
 @return `true if 'p' is contained by 'r', false otherwise.`
*>
macro bool SDLFPoint.in_frect(&p, SDLFRect* r) => (
    (
        p && r &&
        (p.x >= r.x) && (p.x <= (r.x + r.w)) &&
        (p.y >= r.y) && (p.y <= (r.y + r.h))
    ) ? true : false
);

<*
 Determine whether a floating point rectangle can contain any point.
 This function is available since SDL 3.2.0.

 A rectangle is considered "empty" for this function if `r` is NULL, or if
 `r`'s width and/or height are < 0.0f.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param r : `the rectangle to test.`
 @return `true if the rectangle is "empty", false otherwise.`
*>
macro bool SDLFRect.empty(&r) => (
    (
        (!r) ||
        (r.w < 0.0) || (r.h < 0.0)
    ) ? true : false
);

<*
 Determine whether two floating point rectangles are equal, within some
 given epsilon.
 This function is available since SDL 3.2.0.

 Rectangles are considered equal if both are not NULL and each of their x,
 y, width and height are within `epsilon` of each other. If you don't know
 what value to use for `epsilon`, you should call the SDL_RectsEqualFloat
 function instead.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param a : `the first rectangle to test.`
 @param b : `the second rectangle to test.`
 @param epsilon : `the epsilon value for comparison.`
 @return `true if the rectangles are equal, false otherwise.`
*>
macro bool SDLFRect.equal_epsilon(&a, SDLFRect* b, float epsilon) => (
    (
        a && b && (
            (a == b) || (
                (fabsf(a.x - b.x) <= epsilon) &&
                (fabsf(a.y - b.y) <= epsilon) &&
                (fabsf(a.w - b.w) <= epsilon) &&
                (fabsf(a.h - b.h) <= epsilon)
            )
        )
    ) ? true : false
);

<*
 Determine whether two floating point rectangles are equal, within a default
 epsilon.
 This function is available since SDL 3.2.0.

 Rectangles are considered equal if both are not NULL and each of their x,
 y, width and height are within SDL_FLT_EPSILON of each other. This is often
 a reasonable way to compare two floating point rectangles and deal with the
 slight precision variations in floating point calculations that tend to pop
 up.

 Note that this is a forced-inline function in a header, and not a public
 API function available in the SDL library (which is to say, the code is
 embedded in the calling program and the linker and dynamic loader will not
 be able to find this function inside SDL itself).

 threadsafety: It is safe to call this function from any thread.

 @param a : `the first rectangle to test.`
 @param b : `the second rectangle to test.`
 @return `true if the rectangles are equal, false otherwise.`
*>
macro bool SDLFRect.equal(&a, SDLFRect* b) => (
    SDLFRect.equal_epsilon(a, b, math::FLOAT_EPSILON)
);

<*
 Determine whether two rectangles intersect with float precision.
 This function is available since SDL 3.2.0.

 If either pointer is NULL the function will return false.

 @param a : `an SDL_FRect structure representing the first rectangle.`
 @param b : `an SDL_FRect structure representing the second rectangle.`
 @return `true if there is an intersection, false otherwise.`
*>
extern fn bool SDLFRect.has_intersection(&a, SDLFRect* b) @extern("SDL_HasRectIntersectionFloat");

<*
 Calculate the intersection of two rectangles with float precision.
 This function is available since SDL 3.2.0.

 If `result` is NULL then this function will return false.

 @param a : `an SDL_FRect structure representing the first rectangle.`
 @param b : `an SDL_FRect structure representing the second rectangle.`
 @param result : `an SDL_FRect structure filled in with the intersection of
               rectangles 'a' and 'b'.`
 @return `true if there is an intersection, false otherwise.`
*>
extern fn bool SDLFRect.get_intersection(&a, SDLFRect* b, SDLFRect* result) @extern("SDL_GetRectIntersectionFloat");

<*
 Calculate the union of two rectangles with float precision.
 This function is available since SDL 3.2.0.

 @param a : `an SDL_FRect structure representing the first rectangle.`
 @param b : `an SDL_FRect structure representing the second rectangle.`
 @param result : `an SDL_FRect structure filled in with the union of rectangles
                 'a' and 'b'.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLFRect.get_union(&a, SDLFRect* b, SDLFRect* result) @extern("SDL_GetRectUnionFloat");

<*
 Calculate a minimal rectangle enclosing a set of points with float
 precision.
 This function is available since SDL 3.2.0.

 If `clip` is not NULL then only points inside of the clipping rectangle are
 considered.

 @param points : `an array of SDL_FPoint structures representing points to be
                  enclosed.`
 @param count : `the number of structures in the 'points' array.`
 @param clip : `an SDL_FRect used for clipping or NULL to enclose all points.`
 @param result : `an SDL_FRect structure filled in with the minimal enclosing
                  rectangle.`
 @return `true if any points were enclosed or false if all the points were
          outside of the clipping rectangle.`
*>
extern fn bool get_frect_enclosing_points(SDLFPoint* points, CInt count, SDLFRect* clip, SDLFRect* result) @extern("SDL_GetRectEnclosingPointsFloat");

<*
 Calculate the intersection of a rectangle and line segment with float
 precision.
 This function is available since SDL 3.2.0.

 This function is used to clip a line segment to a rectangle. A line segment
 contained entirely within the rectangle or that does not intersect will
 remain unchanged. A line segment that crosses the rectangle at either or
 both ends will be clipped to the boundary of the rectangle and the new
 coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.

 @param rect : `an SDL_FRect structure representing the rectangle to intersect.`
 @param x1 : `a pointer to the starting X-coordinate of the line.`
 @param y1 : `a pointer to the starting Y-coordinate of the line.`
 @param x2 : `a pointer to the ending X-coordinate of the line.`
 @param y2 : `a pointer to the ending Y-coordinate of the line.`
 @return `true if there is an intersection, false otherwise.`
*>
extern fn bool SDLFRect.get_line_intersection(&rect, float* x1, float* y1, float* x2, float* y2) @extern("SDL_GetRectAndLineIntersectionFloat");
