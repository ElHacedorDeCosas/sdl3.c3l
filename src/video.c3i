<*
 SDL Video
 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryVideo
 TODO: add missing documentation
*>
module sdl::video;

import sdl::stdinc;
import sdl::properties;
import sdl::pixels;
import sdl::rect;
import sdl::surface;

typedef SDLDisplayID = uint;
typedef SDLWindowID = uint;

const SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER = "SDL.video.wayland.wl_display";

enum SDLSystemTheme
{
    UNKNOWN,   // Unknown system theme
    LIGHT,     // Light colored system theme
    DARK       // Dark colored system theme
}

typedef SDLDisplayModeData = void;

struct SDLDisplayMode
{
    SDLDisplayID display_id;        // the display this mode is associated with
    SDLPixelFormat format;         // pixel format
    int w;                         // width
    int h;                         // height
    float pixel_density;           // scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels)
    float refresh_rate;            // refresh rate (or 0.0f for unspecified)
    int refresh_rate_numerator;    // precise refresh rate numerator (or 0 for unspecified)
    int refresh_rate_denominator;  // precise refresh rate denominator

    SDLDisplayModeData* internal;  // Private

}

enum SDLDisplayOrientation
{
    UNKNOWN,            // The display orientation can't be determined
    LANDSCAPE,          // The display is in landscape mode, with the right side up, relative to portrait mode
    LANDSCAPE_FLIPPED,  // The display is in landscape mode, with the left side up, relative to portrait mode
    PORTRAIT,           // The display is in portrait mode
    PORTRAIT_FLIPPED    // The display is in portrait mode, upside down
}

typedef SDLWindow = void;

enum SDLWindowFlags : const ulong
{
	FULLSCREEN           = 0x0000000000000001u,    // window is in fullscreen mode
	OPENGL               = 0x0000000000000002u,    // window usable with OpenGL context
	OCCLUDED             = 0x0000000000000004u,    // window is occluded
	HIDDEN               = 0x0000000000000008u,    // window is neither mapped onto the desktop nor shown in the taskbar/dock/window list; SDL_ShowWindow() is required for it to become visible
	BORDERLESS           = 0x0000000000000010u,    // no window decoration
	RESIZABLE            = 0x0000000000000020u,    // window can be resized
	MINIMIZED            = 0x0000000000000040u,    // window is minimized
	MAXIMIZED            = 0x0000000000000080u,    // window is maximized
	MOUSE_GRABBED        = 0x0000000000000100u,    // window has grabbed mouse input
	INPUT_FOCUS          = 0x0000000000000200u,    // window has input focus
	MOUSE_FOCUS          = 0x0000000000000400u,    // window has mouse focus
	EXTERNAL             = 0x0000000000000800u,    // window not created by SDL
	MODAL                = 0x0000000000001000u,    // window is modal
	HIGH_PIXEL_DENSITY   = 0x0000000000002000u,    // window uses high pixel density back buffer if possible
	MOUSE_CAPTURE        = 0x0000000000004000u,    // window has mouse captured (unrelated to MOUSE_GRABBED)
	MOUSE_RELATIVE_MODE  = 0x0000000000008000u,    // window has relative mode enabled
	ALWAYS_ON_TOP        = 0x0000000000010000u,    // window should always be above others
	UTILITY              = 0x0000000000020000u,    // window should be treated as a utility window, not showing in the task bar and window list
	TOOLTIP              = 0x0000000000040000u,    // window should be treated as a tooltip and does not get mouse or keyboard focus, requires a parent window
	POPUP_MENU           = 0x0000000000080000u,    // window should be treated as a popup menu, requires a parent window
	KEYBOARD_GRABBED     = 0x0000000000100000u,    // window has grabbed keyboard input
	VULKAN               = 0x0000000010000000u,    // window usable for Vulkan surface
	METAL                = 0x0000000020000000u,    // window usable for Metal view
	TRANSPARENT          = 0x0000000040000000u,    // window with transparent buffer
	NOT_FOCUSABLE        = 0x0000000080000000u,    // window should not be focusable
}

const WINDOW_POS_UNDEFINED_MASK = 0x1FFF0000u;
const WINDOW_POS_UNDEFINED = WINDOW_POS_UNDEFINED_MASK;
const WINDOW_POS_CENTERED_MASK = 0x2FFF0000u;
const WINDOW_POS_CENTERED = WINDOW_POS_CENTERED_MASK;

macro window_pos_undefined_display(x) => WINDOW_POS_UNDEFINED_MASK | x;
macro window_pos_centered_display(x) => WINDOW_POS_CENTERED_MASK | x;
macro bool window_pos_is_undefined(x) => x & 0xFFFF0000 == WINDOW_POS_UNDEFINED_MASK;
macro bool window_pos_is_centered(x) => x & 0xFFFF0000 == WINDOW_POS_CENTERED_MASK;

enum SDLFlashOperation
{
   CANCEL,                   // Cancel any window flash state
   BRIEFLY,                  // Flash the window briefly to get attention
   UNTIL_FOCUSED             // Flash the window until it gets focus
}

enum SDLHitTestResult
{
    NORMAL,             // Region is normal. No special properties.
    DRAGGABLE,          // Region can drag entire window.
    RESIZE_TOPLEFT,     // Region is the resizable top-left corner border.
    RESIZE_TOP,         // Region is the resizable top border.
    RESIZE_TOPRIGHT,    // Region is the resizable top-right corner border.
    RESIZE_RIGHT,       // Region is the resizable right border.
    RESIZE_BOTTOMRIGHT, // Region is the resizable bottom-right corner border.
    RESIZE_BOTTOM,      // Region is the resizable bottom border.
    RESIZE_BOTTOMLEFT,  // Region is the resizable bottom-left corner border.
    RESIZE_LEFT         // Region is the resizable left border.
}

typedef SDLGLContextState = void;
alias SDLGLContext = SDLGLContextState*;

typedef SDLEGLDisplay = void*;
typedef SDLEGLConfig = void*;
typedef SDLEGLSurface = void*;
typedef SDLEGLAttrib = iptr;
typedef SDLEGLint = CInt ;

alias SDLEGLAttribArrayCallback = fn SDLEGLAttrib*(void* userdata);
alias SDLEGLIntArrayCallback = fn SDLEGLint*(void *userdata, SDLEGLDisplay display, SDLEGLConfig config);

enum SDLGLAttr
{
    RED_SIZE,                    // the minimum number of bits for the red channel of the color buffer; defaults to 8.
    GREEN_SIZE,                  // the minimum number of bits for the green channel of the color buffer; defaults to 8.
    BLUE_SIZE,                   // the minimum number of bits for the blue channel of the color buffer; defaults to 8.
    ALPHA_SIZE,                  // the minimum number of bits for the alpha channel of the color buffer; defaults to 8.
    BUFFER_SIZE,                 // the minimum number of bits for frame buffer size; defaults to 0.
    DOUBLEBUFFER,                // whether the output is single or double buffered; defaults to double buffering on.
    DEPTH_SIZE,                  // the minimum number of bits in the depth buffer; defaults to 16.
    STENCIL_SIZE,                // the minimum number of bits in the stencil buffer; defaults to 0.
    ACCUM_RED_SIZE,              // the minimum number of bits for the red channel of the accumulation buffer; defaults to 0.
    ACCUM_GREEN_SIZE,            // the minimum number of bits for the green channel of the accumulation buffer; defaults to 0.
    ACCUM_BLUE_SIZE,             // the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0.
    ACCUM_ALPHA_SIZE,            // the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0.
    STEREO,                      // whether the output is stereo 3D; defaults to off.
    MULTISAMPLEBUFFERS,          // the number of buffers used for multisample anti-aliasing; defaults to 0.
    MULTISAMPLESAMPLES,          // the number of samples used around the current pixel used for multisample anti-aliasing.
    ACCELERATED_VISUAL,          // set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either.
    RETAINED_BACKING,            // not used (deprecated).
    CONTEXT_MAJOR_VERSION,       // OpenGL context major version.
    CONTEXT_MINOR_VERSION,       // OpenGL context minor version.
    CONTEXT_FLAGS,               // some combination of 0 or more of elements of the SDLGLContextFlag enumeration; defaults to 0.
    CONTEXT_PROFILE_MASK,        // type of GL context (Core, Compatibility, ES). See SDLGLProfile; default value depends on platform.
    SHARE_WITH_CURRENT_CONTEXT,  // OpenGL context sharing; defaults to 0.
    FRAMEBUFFER_SRGB_CAPABLE,    // requests sRGB capable visual; defaults to 0.
    CONTEXT_RELEASE_BEHAVIOR,    // sets context the release behavior. See SDLGLContextReleaseFlag; defaults to FLUSH.
    CONTEXT_RESET_NOTIFICATION,  // set context reset notification. See SDLGLContextResetNotification; defaults to NO_NOTIFICATION.
    CONTEXT_NO_ERROR,
    FLOATBUFFERS,
    EGL_PLATFORM
}

typedef SDLGLProfile = uint;

const SDLGLProfile GL_CONTEXT_PROFILE_CORE          = 0x0001;  // OpenGL Core Profile context
const SDLGLProfile GL_CONTEXT_PROFILE_COMPATIBILITY = 0x0002;  // OpenGL Compatibility Profile context
const SDLGLProfile GL_CONTEXT_PROFILE_ES            = 0x0004;  // GLX_CONTEXT_ES2_PROFILE_BIT_EXT


typedef SDLGLContextFlag = uint;

const SDLGLContextFlag GL_CONTEXT_DEBUG_FLAG              = 0x0001;
const SDLGLContextFlag GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002;
const SDLGLContextFlag GL_CONTEXT_ROBUST_ACCESS_FLAG      = 0x0004;
const SDLGLContextFlag GL_CONTEXT_RESET_ISOLATION_FLAG    = 0x0008;


typedef SDLGLContextReleaseFlag = uint;

const SDLGLContextReleaseFlag GL_CONTEXT_RELEASE_BEHAVIOR_NONE  = 0x0000;
const SDLGLContextReleaseFlag GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x0001;

typedef SDLGLContextResetNotification = uint;

const SDLGLContextResetNotification GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000;
const SDLGLContextResetNotification GL_CONTEXT_RESET_LOSE_CONTEXT    = 0x0001;

const PROP_DISPLAY_HDR_ENABLED_BOOLEAN             = "SDL.display.HDR_enabled";
const PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER = "SDL.display.KMSDRM.panel_orientation";

const PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN               = "SDL.window.create.always_on_top";
const PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN                  = "SDL.window.create.borderless";
const PROP_WINDOW_CREATE_CONSTRAIN_POPUP_BOOLEAN             = "SDL.window.create.constrain_popup";
const PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN                   = "SDL.window.create.focusable";
const PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN   = "SDL.window.create.external_graphics_context";
const PROP_WINDOW_CREATE_FLAGS_NUMBER                        = "SDL.window.create.flags";
const PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN                  = "SDL.window.create.fullscreen";
const PROP_WINDOW_CREATE_HEIGHT_NUMBER                       = "SDL.window.create.height";
const PROP_WINDOW_CREATE_HIDDEN_BOOLEAN                      = "SDL.window.create.hidden";
const PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN          = "SDL.window.create.high_pixel_density";
const PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN                   = "SDL.window.create.maximized";
const PROP_WINDOW_CREATE_MENU_BOOLEAN                        = "SDL.window.create.menu";
const PROP_WINDOW_CREATE_METAL_BOOLEAN                       = "SDL.window.create.metal";
const PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN                   = "SDL.window.create.minimized";
const PROP_WINDOW_CREATE_MODAL_BOOLEAN                       = "SDL.window.create.modal";
const PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN               = "SDL.window.create.mouse_grabbed";
const PROP_WINDOW_CREATE_OPENGL_BOOLEAN                      = "SDL.window.create.opengl";
const PROP_WINDOW_CREATE_PARENT_POINTER                      = "SDL.window.create.parent";
const PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN                   = "SDL.window.create.resizable";
const PROP_WINDOW_CREATE_TITLE_STRING                        = "SDL.window.create.title";
const PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN                 = "SDL.window.create.transparent";
const PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN                     = "SDL.window.create.tooltip";
const PROP_WINDOW_CREATE_UTILITY_BOOLEAN                     = "SDL.window.create.utility";
const PROP_WINDOW_CREATE_VULKAN_BOOLEAN                      = "SDL.window.create.vulkan";
const PROP_WINDOW_CREATE_WIDTH_NUMBER                        = "SDL.window.create.width";
const PROP_WINDOW_CREATE_X_NUMBER                            = "SDL.window.create.x";
const PROP_WINDOW_CREATE_Y_NUMBER                            = "SDL.window.create.y";
const PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER                = "SDL.window.create.cocoa.window";
const PROP_WINDOW_CREATE_COCOA_VIEW_POINTER                  = "SDL.window.create.cocoa.view";
const PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN = "SDL.window.create.wayland.surface_role_custom";
const PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN   = "SDL.window.create.wayland.create_egl_window";
const PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER          = "SDL.window.create.wayland.wl_surface";
const PROP_WINDOW_CREATE_WIN32_HWND_POINTER                  = "SDL.window.create.win32.hwnd";
const PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER     = "SDL.window.create.win32.pixel_format_hwnd";
const PROP_WINDOW_CREATE_X11_WINDOW_NUMBER                   = "SDL.window.create.x11.window";

const PROP_WINDOW_SHAPE_POINTER                               = "SDL.window.shape";
const PROP_WINDOW_HDR_ENABLED_BOOLEAN                         = "SDL.window.HDR_enabled";
const PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT                       = "SDL.window.SDR_white_level";
const PROP_WINDOW_HDR_HEADROOM_FLOAT                          = "SDL.window.HDR_headroom";
const PROP_WINDOW_ANDROID_WINDOW_POINTER                      = "SDL.window.android.window";
const PROP_WINDOW_ANDROID_SURFACE_POINTER                     = "SDL.window.android.surface";
const PROP_WINDOW_UIKIT_WINDOW_POINTER                        = "SDL.window.uikit.window";
const PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER                 = "SDL.window.uikit.metal_view_tag";
const PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER             = "SDL.window.uikit.opengl.framebuffer";
const PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER            = "SDL.window.uikit.opengl.renderbuffer";
const PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER     = "SDL.window.uikit.opengl.resolve_framebuffer";
const PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER                  = "SDL.window.kmsdrm.dev_index";
const PROP_WINDOW_KMSDRM_DRM_FD_NUMBER                        = "SDL.window.kmsdrm.drm_fd";
const PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER                   = "SDL.window.kmsdrm.gbm_dev";
const PROP_WINDOW_COCOA_WINDOW_POINTER                        = "SDL.window.cocoa.window";
const PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER                 = "SDL.window.cocoa.metal_view_tag";
const PROP_WINDOW_OPENVR_OVERLAY_ID                           = "SDL.window.openvr.overlay_id";
const PROP_WINDOW_VIVANTE_DISPLAY_POINTER                     = "SDL.window.vivante.display";
const PROP_WINDOW_VIVANTE_WINDOW_POINTER                      = "SDL.window.vivante.window";
const PROP_WINDOW_VIVANTE_SURFACE_POINTER                     = "SDL.window.vivante.surface";
const PROP_WINDOW_WIN32_HWND_POINTER                          = "SDL.window.win32.hwnd";
const PROP_WINDOW_WIN32_HDC_POINTER                           = "SDL.window.win32.hdc";
const PROP_WINDOW_WIN32_INSTANCE_POINTER                      = "SDL.window.win32.instance";
const PROP_WINDOW_WAYLAND_DISPLAY_POINTER                     = "SDL.window.wayland.display";
const PROP_WINDOW_WAYLAND_SURFACE_POINTER                     = "SDL.window.wayland.surface";
const PROP_WINDOW_WAYLAND_VIEWPORT_POINTER                    = "SDL.window.wayland.viewport";
const PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER                  = "SDL.window.wayland.egl_window";
const PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER                 = "SDL.window.wayland.xdg_surface";
const PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER                = "SDL.window.wayland.xdg_toplevel";
const PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING   = "SDL.window.wayland.xdg_toplevel_export_handle";
const PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER                   = "SDL.window.wayland.xdg_popup";
const PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER              = "SDL.window.wayland.xdg_positioner";
const PROP_WINDOW_X11_DISPLAY_POINTER                         = "SDL.window.x11.display";
const PROP_WINDOW_X11_SCREEN_NUMBER                           = "SDL.window.x11.screen";
const PROP_WINDOW_X11_WINDOW_NUMBER                           = "SDL.window.x11.window";

const WINDOW_SURFACE_VSYNC_DISABLED = 0;
const WINDOW_SURFACE_VSYNC_ADAPTIVE = -1;

alias SDLHitTest = fn SDLHitTestResult(SDLWindow* win, SDLPoint* area, void* data);

extern fn CInt get_num_video_drivers() @extern("SDL_GetNumVideoDrivers");
extern fn ZString get_video_driver(CInt index) @extern("SDL_GetVideoDriver");
extern fn ZString get_current_video_driver() @extern("SDL_GetCurrentVideoDriver");
extern fn SDLSystemTheme get_system_theme() @extern("SDL_GetSystemTheme");
extern fn SDLDisplayID* get_displays(CInt* count) @extern("SDL_GetDisplays");
extern fn SDLDisplayID get_primary_display() @extern("SDL_GetPrimaryDisplay");
extern fn SDLPropertiesID SDLDisplayID.get_properties(display_id) @extern("SDL_GetDisplayProperties");
extern fn ZString SDLDisplayID.get_name(display_id) @extern("SDL_GetDisplayName");
extern fn bool SDLDisplayID.get_bounds(display_id, SDLRect* rect) @extern("SDL_GetDisplayBounds");
extern fn bool SDLDisplayID.get_usable_bounds(display_id, SDLRect* rect) @extern("SDL_GetDisplayUsableBounds");
extern fn SDLDisplayOrientation SDLDisplayID.get_natural_orientation(display_id) @extern("SDL_GetNaturalDisplayOrientation");
extern fn SDLDisplayOrientation SDLDisplayID.get_current_orientation(display_id) @extern("SDL_GetCurrentDisplayOrientation");
extern fn float SDLDisplayID.get_content_scale(display_id) @extern("SDL_GetDisplayContentScale");
extern fn SDLDisplayMode** SDLDisplayID.get_fullscreen_modes(display_id, CInt* count) @extern("SDL_GetFullscreenDisplayModes");
extern fn bool SDLDisplayID.get_closest_fullscreen_mode(display_id, CInt w, CInt h, float refresh_rate, bool include_high_density_modes, SDLDisplayMode* closest) @extern("SDL_GetClosestFullscreenDisplayMode");
extern fn SDLDisplayMode* SDLDisplayID.get_desktop_mode(display_id) @extern("SDL_GetDesktopDisplayMode");
extern fn SDLDisplayMode* SDLDisplayID.get_current_mode(display_id) @extern("SDL_GetCurrentDisplayMode");
extern fn SDLDisplayID get_display_for_point(SDLPoint* point) @extern("SDL_GetDisplayForPoint");
extern fn SDLDisplayID get_display_for_rect(SDLRect* rect) @extern("SDL_GetDisplayForRect");
extern fn SDLDisplayID SDLWindow.get_display(&window) @extern("SDL_GetDisplayForWindow");
extern fn float SDLWindow.get_pixel_density(&window) @extern("SDL_GetWindowPixelDensity");
extern fn float SDLWindow.get_display_scale(&window) @extern("SDL_GetWindowDisplayScale");
extern fn bool SDLWindow.set_fullscreen_mode(&window, SDLDisplayMode* mode) @extern("SDL_SetWindowFullscreenMode");
extern fn SDLDisplayMode* SDLWindow.get_fullscreen_mode(&window) @extern("SDL_GetWindowFullscreenMode");
extern fn void* SDLWindow.get_icc_profile(&window, usz* size) @extern("SDL_GetWindowICCProfile");
extern fn SDLPixelFormat SDLWindow.get_pixel_format(&window) @extern("SDL_GetWindowPixelFormat");
extern fn SDLWindow** get_windows(CInt* count) @extern("SDL_GetWindows");
extern fn SDLWindow* create_window(ZString title, CInt w, CInt h, SDLWindowFlags flags) @extern("SDL_CreateWindow");
extern fn SDLWindow* create_popup_window(SDLWindow* parent, CInt offset_x, CInt offset_y, CInt w, CInt h, SDLWindowFlags flags) @extern("SDL_CreatePopupWindow");
extern fn SDLWindow* create_window_with_properties(SDLPropertiesID props) @extern("SDL_CreateWindowWithProperties");
extern fn SDLWindowID SDLWindow.get_id(&window) @extern("SDL_GetWindowID");
extern fn SDLWindow* get_window_from_id(SDLWindowID id) @extern("SDL_GetWindowFromID");
extern fn SDLWindow* SDLWindow.get_parent(&window) @extern("SDL_GetWindowParent");
extern fn SDLPropertiesID SDLWindow.get_properties(&window) @extern("SDL_GetWindowProperties");
extern fn SDLWindowFlags SDLWindow.get_flags(&window) @extern("SDL_GetWindowFlags");
extern fn bool SDLWindow.set_title(&window, ZString title) @extern("SDL_SetWindowTitle");
extern fn ZString SDLWindow.get_title(&window) @extern("SDL_GetWindowTitle");
extern fn bool SDLWindow.set_icon(&window, SDLSurface* icon) @extern("SDL_SetWindowIcon");
extern fn bool SDLWindow.set_position(&window, CInt x, CInt y) @extern("SDL_SetWindowPosition");
extern fn bool SDLWindow.get_position(&window, CInt* x, CInt* y) @extern("SDL_GetWindowPosition");
extern fn bool SDLWindow.set_size(&window, CInt w, CInt h) @extern("SDL_SetWindowSize");
extern fn bool SDLWindow.get_size(&window, CInt* w, CInt* h) @extern("SDL_GetWindowSize");
extern fn bool SDLWindow.get_safe_area(&window, SDLRect* rect) @extern("SDL_GetWindowSafeArea");
extern fn bool SDLWindow.set_aspect_ratio(&window, float min_aspect, float max_aspect) @extern("SDL_SetWindowAspectRatio");
extern fn bool SDLWindow.get_aspect_ratio(&window, float* min_aspect, float* max_aspect) @extern("SDL_GetWindowAspectRatio");
extern fn bool SDLWindow.get_borders_size(&window, CInt* top, CInt* left, CInt *bottom, CInt *right) @extern("SDL_GetWindowBordersSize");
extern fn bool SDLWindow.get_size_in_pixels(&window, CInt* w, CInt* h) @extern("SDL_GetWindowSizeInPixels");
extern fn bool SDLWindow.set_minimum_size(&window, CInt min_w, CInt min_h) @extern("SDL_SetWindowMinimumSize");
extern fn bool SDLWindow.get_minimum_size(&window, CInt* w, CInt* h) @extern("SDL_GetWindowMinimumSize");
extern fn bool SDLWindow.set_maximum_size(&window, CInt max_w, CInt max_h) @extern("SDL_SetWindowMaximumSize");
extern fn bool SDLWindow.get_maximum_size(&window, CInt* w, CInt* h) @extern("SDL_GetWindowMaximumSize");
extern fn bool SDLWindow.set_bordered(&window, bool bordered) @extern("SDL_SetWindowBordered");
extern fn bool SDLWindow.set_resizable(&window, bool resizable) @extern("SDL_SetWindowResizable");
extern fn bool SDLWindow.set_always_on_top(&window, bool on_top) @extern("SDL_SetWindowAlwaysOnTop");
extern fn bool SDLWindow.show(&window) @extern("SDL_ShowWindow");
extern fn bool SDLWindow.hide(&window) @extern("SDL_HideWindow");
extern fn bool SDLWindow.raise(&window) @extern("SDL_RaiseWindow");
extern fn bool SDLWindow.maximize(&window) @extern("SDL_MaximizeWindow");
extern fn bool SDLWindow.minimize(&window) @extern("SDL_MinimizeWindow");
extern fn bool SDLWindow.restore(&window) @extern("SDL_RestoreWindow");
extern fn bool SDLWindow.set_fullscreen(&window, bool fullscreen) @extern("SDL_SetWindowFullscreen");
extern fn bool SDLWindow.sync(&window) @extern("SDL_SyncWindow");
extern fn bool SDLWindow.has_surface(&window) @extern("SDL_WindowHasSurface");
extern fn SDLSurface* SDLWindow.get_surface(&window) @extern("SDL_GetWindowSurface");
extern fn bool SDLWindow.set_surface_vsync(&window, CInt vsync) @extern("SDL_SetWindowSurfaceVSync");
extern fn bool SDLWindow.get_surface_vsync(&window, CInt* vsync) @extern("SDL_GetWindowSurfaceVSync");
extern fn bool SDLWindow.update_surface(&window) @extern("SDL_UpdateWindowSurface");
extern fn bool SDLWindow.update_surface_rects(&window, SDLRect* rects, CInt numrects) @extern("SDL_UpdateWindowSurfaceRects");
extern fn bool SDLWindow.destroy_surface(&window) @extern("SDL_DestroyWindowSurface");
extern fn bool SDLWindow.set_keyboard_grab(&window, bool grabbed) @extern("SDL_SetWindowKeyboardGrab");
extern fn bool SDLWindow.set_mouse_grab(&window, bool grabbed) @extern("SDL_SetWindowMouseGrab");
extern fn bool SDLWindow.get_keyboard_grab(&window) @extern("SDL_GetWindowKeyboardGrab");
extern fn bool SDLWindow.get_mouse_grab(&window) @extern("SDL_GetWindowMouseGrab");
extern fn SDLWindow* get_grabbed_window() @extern("SDL_GetGrabbedWindow");
extern fn bool SDLWindow.set_mouse_rect(&window, SDLRect* rect) @extern("SDL_SetWindowMouseRect");
extern fn SDLRect* SDLWindow.get_mouse_rect(&window) @extern("SDL_GetWindowMouseRect");
extern fn bool SDLWindow.set_opacity(&window, float opacity) @extern("SDL_SetWindowOpacity");
extern fn float SDLWindow.get_opacity(&window) @extern("SDL_GetWindowOpacity");
extern fn bool SDLWindow.set_parent(&window, SDLWindow* parent) @extern("SDL_SetWindowParent");
extern fn bool SDLWindow.set_modal(&window, bool modal) @extern("SDL_SetWindowModal");
extern fn bool SDLWindow.set_focusable(&window, bool focusable) @extern("SDL_SetWindowFocusable");
extern fn bool SDLWindow.show_system_menu(&window, CInt x, CInt y) @extern("SDL_ShowWindowSystemMenu");
extern fn bool SDLWindow.set_hit_test(&window, SDLHitTest callback, void* callback_data) @extern("SDL_SetWindowHitTest");
extern fn bool SDLWindow.set_shape(&window, SDLSurface* shape) @extern("SDL_SetWindowShape");
extern fn bool SDLWindow.flash(&window, SDLFlashOperation operation) @extern("SDL_FlashWindow");
extern fn void SDLWindow.destroy(&window) @extern("SDL_DestroyWindow");
extern fn bool screen_saver_enabled() @extern("SDL_ScreenSaverEnabled");
extern fn bool enable_screen_saver() @extern("SDL_EnableScreenSaver");
extern fn bool disable_screen_saver() @extern("SDL_DisableScreenSaver");
extern fn bool gl_load_library(ZString path) @extern("SDL_GL_LoadLibrary");
extern fn SDLFunctionPointer gl_get_proc_address(ZString proc) @extern("SDL_GL_GetProcAddress");
extern fn SDLFunctionPointer egl_get_proc_address(ZString proc) @extern("SDL_EGL_GetProcAddress");
extern fn void gl_unload_library() @extern("SDL_GL_UnloadLibrary");
extern fn bool gl_extension_supported(ZString extension) @extern("SDL_GL_ExtensionSupported");
extern fn void gl_reset_attributes() @extern("SDL_GL_ResetAttributes");
extern fn bool gl_set_attribute(SDLGLAttr attr, CInt value) @extern("SDL_GL_SetAttribute");
extern fn bool gl_get_attribute(SDLGLAttr attr, CInt *value) @extern("SDL_GL_GetAttribute");
extern fn SDLGLContext gl_create_context(SDLWindow* window) @extern("SDL_GL_CreateContext");
extern fn bool gl_make_current(SDLWindow* window, SDLGLContext context) @extern("SDL_GL_MakeCurrent");
extern fn SDLWindow* gl_get_current_window() @extern("SDL_GL_GetCurrentWindow");
extern fn SDLGLContext gl_get_current_context() @extern("SDL_GL_GetCurrentContext");
extern fn SDLEGLDisplay egl_get_current_display() @extern("SDL_EGL_GetCurrentDisplay");
extern fn SDLEGLConfig egl_get_current_config() @extern("SDL_EGL_GetCurrentConfig");
extern fn SDLEGLSurface egl_get_window_surface(SDLWindow* window) @extern("SDL_EGL_GetWindowSurface");
extern fn void egl_set_attribute_callbacks(SDLEGLAttribArrayCallback platform_attrib_callback, SDLEGLIntArrayCallback surface_attrib_callback, SDLEGLIntArrayCallback context_attrib_callback, void *userdata) @extern("SDL_EGL_SetAttributeCallbacks");
extern fn bool gl_set_swap_interval(CInt interval) @extern("SDL_GL_SetSwapInterval");
extern fn bool gl_get_swap_interval(CInt* interval) @extern("SDL_GL_GetSwapInterval");
extern fn bool gl_swap_window(SDLWindow* window) @extern("SDL_GL_SwapWindow");
extern fn bool gl_destroy_context(SDLGLContext context) @extern("SDL_GL_DestroyContext");
