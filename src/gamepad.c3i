<*
 SDL provides a low-level joystick API, which just treats joysticks as an
 arbitrary pile of buttons, axes, and hat switches. If you're planning to
 write your own control configuration screen, this can give you a lot of
 flexibility, but that's a lot of work, and most things that we consider
 "joysticks" now are actually console-style gamepads. So SDL provides the
 gamepad API on top of the lower-level joystick functionality.

 The difference between a joystick and a gamepad is that a gamepad tells you
 _where_ a button or axis is on the device. You don't speak to gamepads in
 terms of arbitrary numbers like "button 3" or "axis 2" but in standard
 locations: the d-pad, the shoulder buttons, triggers, A/B/X/Y (or
 X/O/Square/Triangle, if you will).

 One turns a joystick into a gamepad by providing a magic configuration
 string, which tells SDL the details of a specific device: when you see this
 specific hardware, if button 2 gets pressed, this is actually D-Pad Up,
 etc.

 SDL has many popular controllers configured out of the box, and users can
 add their own controller details through an environment variable if it's
 otherwise unknown to SDL.

 In order to use these functions, SDL_Init() must have been called with the
 SDL_INIT_GAMEPAD flag. This causes SDL to scan the system for gamepads, and
 load appropriate drivers.

 If you would like to receive gamepad updates while the application is in
 the background, you should set the following hint before calling
 SDL_Init(): SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS

 Gamepads support various optional features such as rumble, color LEDs,
 touchpad, gyro, etc. The support for these features varies depending on the
 controller and OS support available. You can check for LED and rumble
 capabilities at runtime by calling SDL_GetGamepadProperties() and checking
 the various capability properties. You can check for touchpad by calling
 SDL_GetNumGamepadTouchpads() and check for gyro and accelerometer by
 calling SDL_GamepadHasSensor().

 By default SDL will try to use the most capable driver available, but you
 can tune which OS drivers to use with the various joystick hints in
 SDL_hints.h.

 Your application should always support gamepad hotplugging. On some
 platforms like Xbox, Steam Deck, etc., this is a requirement for
 certification. On other platforms, like macOS and Windows when using
 Windows.Gaming.Input, controllers may not be available at startup and will
 come in at some point after you've started processing events.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryGamepad
*>
module sdl;

// TODO: I think this should be void and not void* need's tested.
<*
 The structure used to identify an SDL gamepad
 This struct is available since SDL 3.2.0.
*>
typedef SDLGamepad = void*;

<*
 Standard gamepad types.

 This type does not necessarily map to first-party controllers from
 Microsoft/Sony/Nintendo; in many cases, third-party controllers can report
 as these, either because they were designed for a specific console, or they
 simply most closely match that console's controllers (does it have A/B/X/Y
 buttons or X/O/Square/Triangle? Does it have a touchpad? etc).
*>
enum SDLGamepadType : const
{
	GAMEPAD_TYPE_UNKNOWN = 0,
	GAMEPAD_TYPE_STANDARD,
	GAMEPAD_TYPE_XBOX360,
	GAMEPAD_TYPE_XBOXONE,
	GAMEPAD_TYPE_PS3,
	GAMEPAD_TYPE_PS4,
	GAMEPAD_TYPE_PS5,
	GAMEPAD_TYPE_NINTENDO_SWITCH_PRO,
	GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT,
	GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT,
	GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR,
	GAMEPAD_TYPE_GAMECUBE,
	GAMEPAD_TYPE_COUNT
}

<*
 The list of buttons available on a gamepad
 This enum is available since SDL 3.2.0.

 For controllers that use a diamond pattern for the face buttons, the
 south/east/west/north buttons below correspond to the locations in the
 diamond pattern. For Xbox controllers, this would be A/B/X/Y, for Nintendo
 Switch controllers, this would be B/A/Y/X, for PlayStation controllers this
 would be Cross/Circle/Square/Triangle.

 For controllers that don't use a diamond pattern for the face buttons, the
 south/east/west/north buttons indicate the buttons labeled A, B, C, D, or
 1, 2, 3, 4, or for controllers that aren't labeled, they are the primary,
 secondary, etc. buttons.

 The activate action is often the south button and the cancel action is
 often the east button, but in some regions this is reversed, so your game
 should allow remapping actions based on user preferences.

 You can query the labels for the face buttons using
 SDL_GetGamepadButtonLabel()
*>
enum SDLGamepadButton : const
{
    GAMEPAD_BUTTON_INVALID = -1,
    GAMEPAD_BUTTON_SOUTH,           //Bottom face button (e.g. Xbox A button)
    GAMEPAD_BUTTON_EAST,            //Right face button (e.g. Xbox B button)
    GAMEPAD_BUTTON_WEST,            //Left face button (e.g. Xbox X button)
    GAMEPAD_BUTTON_NORTH,           //Top face button (e.g. Xbox Y button)
    GAMEPAD_BUTTON_BACK,
    GAMEPAD_BUTTON_GUIDE,
    GAMEPAD_BUTTON_START,
    GAMEPAD_BUTTON_LEFT_STICK,
    GAMEPAD_BUTTON_RIGHT_STICK,
    GAMEPAD_BUTTON_LEFT_SHOULDER,
    GAMEPAD_BUTTON_RIGHT_SHOULDER,
    GAMEPAD_BUTTON_DPAD_UP,
    GAMEPAD_BUTTON_DPAD_DOWN,
    GAMEPAD_BUTTON_DPAD_LEFT,
    GAMEPAD_BUTTON_DPAD_RIGHT,
    GAMEPAD_BUTTON_MISC1,           // Additional button (e.g. Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button, Amazon Luna microphone button, Google Stadia capture button)
    GAMEPAD_BUTTON_RIGHT_PADDLE1,   // Upper or primary paddle, under your right hand (e.g. Xbox Elite paddle P1, DualSense Edge RB button, Right Joy-Con SR button)
    GAMEPAD_BUTTON_LEFT_PADDLE1,    // Upper or primary paddle, under your left hand (e.g. Xbox Elite paddle P3, DualSense Edge LB button, Left Joy-Con SL button)
    GAMEPAD_BUTTON_RIGHT_PADDLE2,   // Lower or secondary paddle, under your right hand (e.g. Xbox Elite paddle P2, DualSense Edge right Fn button, Right Joy-Con SL button)
    GAMEPAD_BUTTON_LEFT_PADDLE2,    // Lower or secondary paddle, under your left hand (e.g. Xbox Elite paddle P4, DualSense Edge left Fn button, Left Joy-Con SR button)
    GAMEPAD_BUTTON_TOUCHPAD,        // PS4/PS5 touchpad button
    GAMEPAD_BUTTON_MISC2,           // Additional button
    GAMEPAD_BUTTON_MISC3,           // Additional button (e.g. Nintendo GameCube left trigger click)
    GAMEPAD_BUTTON_MISC4,           // Additional button (e.g. Nintendo GameCube right trigger click)
    GAMEPAD_BUTTON_MISC5,           // Additional button
    GAMEPAD_BUTTON_MISC6,           // Additional button
    GAMEPAD_BUTTON_COUNT
}

<*
 The set of gamepad button labels
 This enum is available since SDL 3.2.0.

 This isn't a complete set, just the face buttons to make it easy to show
 button prompts.

 For a complete set, you should look at the button and gamepad type and have
 a set of symbols that work well with your art style.
*>
enum SDLGamepadButtonLabel
{
    GAMEPAD_BUTTON_LABEL_UNKNOWN,
    GAMEPAD_BUTTON_LABEL_A,
    GAMEPAD_BUTTON_LABEL_B,
    GAMEPAD_BUTTON_LABEL_X,
    GAMEPAD_BUTTON_LABEL_Y,
    GAMEPAD_BUTTON_LABEL_CROSS,
    GAMEPAD_BUTTON_LABEL_CIRCLE,
    GAMEPAD_BUTTON_LABEL_SQUARE,
    GAMEPAD_BUTTON_LABEL_TRIANGLE
}

<*
 The list of axes available on a gamepad
 This enum is available since SDL 3.2.0.

 Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to
 SDL_JOYSTICK_AXIS_MAX, and are centered within ~8000 of zero, though
 advanced UI will allow users to set or autodetect the dead zone, which
 varies between gamepads.

 Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX (fully
 pressed) when reported by SDL_GetGamepadAxis(). Note that this is not the
 same range that will be reported by the lower-level SDL_GetJoystickAxis().
*>
enum SDLGamepadAxis : const
{
    GAMEPAD_AXIS_INVALID = -1,
    GAMEPAD_AXIS_LEFTX,
    GAMEPAD_AXIS_LEFTY,
    GAMEPAD_AXIS_RIGHTX,
    GAMEPAD_AXIS_RIGHTY,
    GAMEPAD_AXIS_LEFT_TRIGGER,
    GAMEPAD_AXIS_RIGHT_TRIGGER,
    GAMEPAD_AXIS_COUNT
}

<*
 Types of gamepad control bindings.
 This enum is available since SDL 3.2.0.

 A gamepad is a collection of bindings that map arbitrary joystick buttons,
 axes and hat switches to specific positions on a generic console-style
 gamepad. This enum is used as part of SDL_GamepadBinding to specify those
 mappings.
*>
enum SDLGamepadBindingType : const
{
    GAMEPAD_BINDTYPE_NONE = 0,
    GAMEPAD_BINDTYPE_BUTTON,
    GAMEPAD_BINDTYPE_AXIS,
    GAMEPAD_BINDTYPE_HAT
}

<*
 A mapping between one joystick input to a gamepad control.
 This struct is available since SDL 3.2.0.

 A gamepad has a collection of several bindings, to say, for example, when
 joystick button number 5 is pressed, that should be treated like the
 gamepad's "start" button.

 SDL has these bindings built-in for many popular controllers, and can add
 more with a simple text string. Those strings are parsed into a collection
 of these structs to make it easier to operate on the data.
*>
struct SDLGamepadBinding
{
    SDLGamepadBindingType input_type;
    union input
    {
        int button;

        struct axis
        {
            int axis;
            int axis_min;
            int axis_max;
        }

        struct hat
        {
            int hat;
            int hat_mask;
        }

    }

    SDLGamepadBindingType output_type;
    union output
    {
        SDLGamepadButton button;

        struct axis
        {
            SDLGamepadAxis axis;
            int axis_min;
            int axis_max;
        }

    }
}

<*
 Add support for gamepads that SDL is unaware of or change the binding of an
 existing gamepad.
 This function is available since SDL 3.2.0.

 The mapping string has the format "GUID,name,mapping", where GUID is the
 string value from SDL_GUIDToString(), name is the human readable string for
 the device and mappings are gamepad mappings to joystick ones. Under
 Windows there is a reserved GUID of "xinput" that covers all XInput
 devices. The mapping format for joystick is:

 - `bX`: a joystick button, index X
 - `hX.Y`: hat X with value Y
 - `aX`: axis X of the joystick

 Buttons can be used as a gamepad axes and vice versa.

 If a device with this GUID is already plugged in, SDL will generate an
 SDL_EVENT_GAMEPAD_ADDED event.

 This string shows an example of a valid mapping for a gamepad:

 ```c
 "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
 ```

 threadsafety: It is safe to call this function from any thread.

 @param mapping : `the mapping string.`
 @return `1 if a new mapping is added, 0 if an existing mapping is updated,
          -1 on failure; call SDL_GetError() for more information.`
*>
extern fn CInt add_gamepad_mapping(ZString mapping) @extern("SDL_AddGamepadMapping");


<*
 Load a set of gamepad mappings from an SDL_IOStream.
 This function is available since SDL 3.2.0.

 You can call this function several times, if needed, to load different
 database files.

 If a new mapping is loaded for an already known gamepad GUID, the later
 version will overwrite the one currently loaded.

 Any new mappings for already plugged in controllers will generate
 SDL_EVENT_GAMEPAD_ADDED events.

 Mappings not belonging to the current platform or with no platform field
 specified will be ignored (i.e. mappings for Linux will be ignored in
 Windows, etc).

 This function will load the text database entirely in memory before
 processing it, so take this into consideration if you are in a memory
 constrained environment.

 threadsafety: It is safe to call this function from any thread.

 @param src : `the data stream for the mappings to be added.`
 @param closeio : `if true, calls SDL_CloseIO() on 'src' before returning, even
                   in the case of an error.`
 @return `the number of mappings added or -1 on failure; call SDL_GetError()
          for more information.`
*>
extern fn CInt add_gamepad_mapping_from_io(SDLIOStream* src, bool closeio) @extern("SDL_AddGamepadMappingsFromIO");

<*
 Load a set of gamepad mappings from a file.
 This function is available since SDL 3.2.0.

 You can call this function several times, if needed, to load different
 database files.

 If a new mapping is loaded for an already known gamepad GUID, the later
 version will overwrite the one currently loaded.

 Any new mappings for already plugged in controllers will generate
 SDL_EVENT_GAMEPAD_ADDED events.

 Mappings not belonging to the current platform or with no platform field
 specified will be ignored (i.e. mappings for Linux will be ignored in
 Windows, etc).

 threadsafety: It is safe to call this function from any thread.

 @param file : `the mappings file to load.`
 @return `the number of mappings added or -1 on failure; call SDL_GetError()
          for more information.`
*>
extern fn CInt add_gamepad_mappings_from_file(ZString file) @extern("SDL_AddGamepadMappingsFromFile");

<*
 Reinitialize the SDL mapping database to its initial state.
 This function is available since SDL 3.2.0.

 This will generate gamepad events as needed if device mappings change.

 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool reload_gamepad_mappings() @extern("SDL_ReloadGamepadMappings");

<*
 Get the current gamepad mappings.
 This function is available since SDL 3.2.0.

 @param count : `a pointer filled in with the number of mappings returned, can
                 be NULL.`
 @return `an array of the mapping strings, NULL-terminated, or NULL on
          failure; call SDL_GetError() for more information. This is a
          single allocation that should be freed with SDL_free() when it is
          no longer needed.`
*>
extern fn ZString* get_gamepad_mappings(CInt* count) @extern("SDL_GetGamepadMappings");

<*
 Get the gamepad mapping string for a given GUID.
 This function is available since SDL 3.2.0.

 @param guid : `a structure containing the GUID for which a mapping is desired.`
 @return `a mapping string or NULL on failure; call SDL_GetError() for more
          information. This should be freed with SDL_free() when it is no
          longer needed.`
*>
extern fn ZString get_gamepad_mapping_for_guid(SDLGuid guid) @extern("SDL_GetGamepadMappingForGUID");

<*
 Get the current mapping of a gamepad.
 This function is available since SDL 3.2.0.

 Details about mappings are discussed with SDL_AddGamepadMapping().

 @param gamepad : `the gamepad you want to get the current mapping for.`
 @return `a string that has the gamepad's mapping or NULL if no mapping is
          available; call SDL_GetError() for more information. This should
          be freed with SDL_free() when it is no longer needed.`
*>
extern fn ZString SDLGamepad.get_gamepad_mapping(&gamepad) @extern("SDL_GetGamepadMapping");

<*
 Set the current mapping of a joystick or gamepad.
 This function is available since SDL 3.2.0.

 Details about mappings are discussed with SDL_AddGamepadMapping().

 @param instance_id : `the joystick instance ID.`
 @param mapping : `the mapping to use for this device, or NULL to clear the
                   mapping.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool set_gamepad_mapping(SDLJoystickID instance_id, ZString mapping) @extern("SDL_SetGamepadMapping");

<*
 Return whether a gamepad is currently connected.
 This function is available since SDL 3.2.0.

 @return `true if a gamepad is connected, false otherwise.`
*>
extern fn bool has_gamepad() @extern("SDL_HasGamepad");

<*
 Get a list of currently connected gamepads.
 This function is available since SDL 3.2.0.

 @param count : `a pointer filled in with the number of gamepads returned, may
                 be NULL.`
 @return `a 0 terminated array of joystick instance IDs or NULL on failure;
          call SDL_GetError() for more information. This should be freed
          with SDL_free() when it is no longer needed.`
*>
extern fn SDLJoystickID* get_gamepads(int* count) @extern("SDL_GetGamepads");

<*
 Check if the given joystick is supported by the gamepad interface.
 This function is available since SDL 3.2.0.

 @param instance_id : `the joystick instance ID.`
 @return `true if the given joystick is supported by the gamepad interface,
          false if it isn't or it's an invalid index.`
*>
extern fn bool is_gamepad(SDLJoystickID instance_id) @extern("SDL_IsGamepad");

<*
 Get the implementation dependent name of a gamepad.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the name of the selected gamepad. If no name can be found, this
          function returns NULL; call SDL_GetError() for more information.`
*>
extern fn ZString get_gamepad_name_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadNameForID");

<*
 Get the implementation dependent path of a gamepad.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the path of the selected gamepad. If no path can be found, this
          function returns NULL; call SDL_GetError() for more information.`
*>
extern fn ZString get_gamepad_path_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadPathForID");

<*
 Get the player index of a gamepad.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the player index of a gamepad, or -1 if it's not available.`
*>
extern fn CInt get_gamepad_player_index_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadPlayerForID");

<*
 Get the implementation-dependent GUID of a gamepad.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the GUID of the selected gamepad. If called on an invalid index,
          this function returns a zero GUID.`
*>
extern fn SDLGuid get_gamepad_guid_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadGUIDForID");

<*
 Get the USB vendor ID of a gamepad, if available.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened. If the vendor ID isn't
 available this function returns 0.

 @param instance_id : `the joystick instance ID.`
 @return `the USB vendor ID of the selected gamepad. If called on an invalid
          index, this function returns zero.`
*>
extern fn ushort get_gamepad_vendor_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadVendorForID");

<*
 Get the USB product ID of a gamepad, if available.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened. If the product ID isn't
 available this function returns 0.

 @param instance_id : `the joystick instance ID.`
 @return `the USB product ID of the selected gamepad. If called on an
          invalid index, this function returns zero.`
*>
extern fn ushort get_gamepad_product_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadProductForID");

<*
 Get the product version of a gamepad, if available.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened. If the product version
 isn't available this function returns 0.

 @param instance_id : `the joystick instance ID.`
 @return `the product version of the selected gamepad. If called on an
          invalid index, this function returns zero.`
*>
extern fn ushort get_gamepad_product_version_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadProductVersionForID");

<*
 Get the type of a gamepad.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the gamepad type.`
*>
extern fn SDLGamepadType get_gamepad_type_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadTypeForID");

<*
 Get the type of a gamepad, ignoring any mapping override.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the gamepad type.`
*>
extern fn SDLGamepadType get_real_gamepad_type_for_id(SDLJoystickID instance_id) @extern("SDL_GetRealGamepadTypeForID");

<*
 Get the mapping of a gamepad.
 This function is available since SDL 3.2.0.

 This can be called before any gamepads are opened.

 @param instance_id : `the joystick instance ID.`
 @return `the mapping string. Returns NULL if no mapping is available. This
          should be freed with SDL_free() when it is no longer needed.`
*>
extern fn ZString get_gamepad_mapping_for_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadMappingForID");

<*
 Open a gamepad for use.
 This function is available since SDL 3.2.0.

 @param instance_id : `the joystick instance ID.`
 @return `a gamepad identifier or NULL if an error occurred; call
          SDL_GetError() for more information.`
*>
extern fn SDLGamepad* open_gamepad(SDLJoystickID instance_id) @extern("SDL_OpenGamepad");

<*
 Get the SDL_Gamepad associated with a joystick instance ID, if it has been
 opened.
 This function is available since SDL 3.2.0.

 @param instance_id : `the joystick instance ID of the gamepad.`
 @return `an SDL_Gamepad on success or NULL on failure or if it hasn't been
          opened yet; call SDL_GetError() for more information.`
*>
extern fn SDLGamepad* get_gamepad_from_id(SDLJoystickID instance_id) @extern("SDL_GetGamepadFromID");

<*
 Get the SDL_Gamepad associated with a player index.
 This function is available since SDL 3.2.0.

 @param player_index : `the player index, which different from the instance ID.`
 @return `the SDL_Gamepad associated with a player index.`
*>
extern fn SDLGamepad* get_gamepad_from_player_index(int player_index) @extern("SDL_GetGamepadFromPlayerIndex");

<*
 Get the properties associated with an opened gamepad.
 This function is available since SDL 3.2.0.

 These properties are shared with the underlying joystick object.

 The following read-only properties are provided by SDL:

 - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED
   that has adjustable brightness
 - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED
   that has adjustable color
 - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a
   player LED
 - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has
   left/right rumble
 - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has
   simple trigger rumble

 @param gamepad : `a gamepad identifier previously returned by
                   SDL_OpenGamepad().`
 @return `a valid property ID on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLPropertiesID SDLGamepad.get_gamepad_properties(&gamepad) @extern("SDL_GetGamepadProperties");

//TODO: check if this is correct
enum SDLPropGamepadCap : const ZString
{
	MONO_LED_BOOLEAN       = (SDLPropGamepadCap)SDLPropJoystickCap.MONO_LED_BOOLEAN,
	RGB_LED_BOOLEAN        = (SDLPropGamepadCap)SDLPropJoystickCap.RGB_LED_BOOLEAN,
	PLAYER_LED_BOOLEAN     = (SDLPropGamepadCap)SDLPropJoystickCap.PLAYER_LED_BOOLEAN,
	RUMBLE_BOOLEAN         = (SDLPropGamepadCap)SDLPropJoystickCap.RUMBLE_BOOLEAN,
	TRIGGER_RUMBLE_BOOLEAN = (SDLPropGamepadCap)SDLPropJoystickCap.TRIGGER_RUMBLE_BOOLEAN,
}

<*
 Get the instance ID of an opened gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad identifier previously returned by
                   SDL_OpenGamepad().`
 @return `the instance ID of the specified gamepad on success or 0 on
          failure; call SDL_GetError() for more information.`
*>
extern fn SDLJoystickID SDLGamepad.get_gamepad_id(&gamepad) @extern("SDL_GetGamepadID");

<*
 Get the implementation-dependent name for an opened gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad identifier previously returned by
                   SDL_OpenGamepad().`
 @return `the implementation dependent name for the gamepad, or NULL if
          there is no name or the identifier passed is invalid.`
*>
extern fn ZString SDLGamepad.get_gamepad_name(&gamepad) @extern("SDL_GetGamepadName");

<*
 Get the implementation-dependent path for an opened gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad identifier previously returned by
                   SDL_OpenGamepad().`
 @return `the implementation dependent path for the gamepad, or NULL if
          there is no path or the identifier passed is invalid.`
*>
extern fn ZString SDLGamepad.get_gamepad_path(&gamepad) @extern("SDL_GetGamepadPath");

<*
 Get the type of an opened gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad object to query.`
 @return `the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
          available.`
*>
extern fn SDLGamepadType SDLGamepad.get_gamepad_type(&gamepad) @extern("SDL_GetGamepadType");

<*
 Get the type of an opened gamepad, ignoring any mapping override.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad object to query.`
 @return `the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
          available.`
*>
extern fn SDLGamepadType SDLGamepad.get_real_gamepad_path(&gamepad) @extern("SDL_GetRealGamepadType");

<*
 Get the player index of an opened gamepad.
 This function is available since SDL 3.2.0.

 For XInput gamepads this returns the XInput user index.

 @param gamepad : `the gamepad object to query.`
 @return `the player index for gamepad, or -1 if it's not available.`
*>
extern fn CInt SDLGamepad.get_gamepad_player_index(&gamepad) @extern("SDL_GetGamepadPlayerIndex");

<*
 Set the player index of an opened gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad object to adjust.`
 @param player_index : `player index to assign to this gamepad, or -1 to clear
                        the player index and turn off player LEDs.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.set_gamepad_player_index(&gamepad, CInt player_index) @extern("SDL_SetGamepadPlayerIndex");

<*
 Get the USB vendor ID of an opened gamepad, if available.
 This function is available since SDL 3.2.0.

 If the vendor ID isn't available this function returns 0.

 @param gamepad : `the gamepad object to query.`
 @return `the USB vendor ID, or zero if unavailable.`
*>
extern fn ushort SDLGamepad.get_gamepad_vendor(&gamepad) @extern("SDL_GetGamepadVendor");

<*
 Get the USB product ID of an opened gamepad, if available.
 This function is available since SDL 3.2.0.

 If the product ID isn't available this function returns 0.

 @param gamepad : `the gamepad object to query.`
 @return `the USB product ID, or zero if unavailable.`
*>
extern fn ushort SDLGamepad.get_gamepad_product(&gamepad) @extern("SDL_GetGamepadProduct");

<*
 Get the product version of an opened gamepad, if available.
 This function is available since SDL 3.2.0.

 If the product version isn't available this function returns 0.

 @param gamepad : `the gamepad object to query.`
 @return `the USB product version, or zero if unavailable.`
*>
extern fn ushort SDLGamepad.get_gamepad_product_version(&gamepad) @extern("SDL_GetGamepadProductVersion");

<*
 Get the firmware version of an opened gamepad, if available.
 This function is available since SDL 3.2.0.

 If the firmware version isn't available this function returns 0.

 @param gamepad : `the gamepad object to query.`
 @return `the gamepad firmware version, or zero if unavailable.`
*>
extern fn ushort SDLGamepad.get_gamepad_firmware_version(&gamepad) @extern("SDL_GetGamepadFirmwareVersion");

<*
 Get the serial number of an opened gamepad, if available.
 This function is available since SDL 3.2.0.

 Returns the serial number of the gamepad, or NULL if it is not available.

 @param gamepad : `the gamepad object to query.`
 @return `the serial number, or NULL if unavailable.`
*>
extern fn ZString SDLGamepad.get_gamepad_serial(&gamepad) @extern("SDL_GetGamepadSerial");

<*
 Get the Steam Input handle of an opened gamepad, if available.
 This function is available since SDL 3.2.0.

 Returns an InputHandle_t for the gamepad that can be used with Steam Input
 API: https://partner.steamgames.com/doc/api/ISteamInput

 @param gamepad : `the gamepad object to query.`
 @return `the gamepad handle, or 0 if unavailable.`
*>
extern fn ulong SDLGamepad.get_gamepad_steam_handle(&gamepad) @extern("SDL_GetGamepadSteamHandle");

<*
 Get the connection state of a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad object to query.`
 @return `the connection state on success or
          'SDL_JOYSTICK_CONNECTION_INVALID' on failure; call SDL_GetError()
          for more information.`
*>
extern fn SDLJoystickConnectionState SDLGamepad.get_gamepad_connection_state(&gamepad) @extern("SDL_GetGamepadConnectionState");

<*
 Get the battery state of a gamepad.
 This function is available since SDL 3.2.0.

 You should never take a battery status as absolute truth. Batteries
 (especially failing batteries) are delicate hardware, and the values
 reported here are best estimates based on what that hardware reports. It's
 not uncommon for older batteries to lose stored power much faster than it
 reports, or completely drain when reporting it has 20 percent left, etc.

 @param gamepad : `the gamepad object to query.`
 @param percent : `a pointer filled in with the percentage of battery life
                left, between 0 and 100, or NULL to ignore. This will be
                filled in with -1 we can't determine a value or there is no
                battery.`
 @return `the current battery state.`
*>
extern fn SDLPowerState SDLGamepad.get_gamepad_power_info(&gamepad, CInt* percent) @extern("SDL_GetGamepadPowerInfo");

<*
 Check if a gamepad has been opened and is currently connected.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad identifier previously returned by
                   SDL_OpenGamepad().`
 @return `true if the gamepad has been opened and is currently connected, or
          false if not.`
*>
extern fn bool SDLGamepad.gamepad_connected(&gamepad) @extern("SDL_GamepadConnected");

<*
 Get the underlying joystick from a gamepad.
 This function is available since SDL 3.2.0.

 This function will give you a SDL_Joystick object, which allows you to use
 the SDL_Joystick functions with a SDL_Gamepad object. This would be useful
 for getting a joystick's position at any given time, even if it hasn't
 moved (moving it would produce an event, which would have the axis' value).

 The pointer returned is owned by the SDL_Gamepad. You should not call
 SDL_CloseJoystick() on it, for example, since doing so will likely cause
 SDL to crash.

 @param gamepad : `the gamepad object that you want to get a joystick from.`
 @return `an SDL_Joystick object, or NULL on failure; call SDL_GetError()
          for more information.`
*>
extern fn SDLJoystick* SDLGamepad.get_gamepad_joystick(&gamepad) @extern("SDL_GetGamepadJoystick");

<*
 Set the state of gamepad event processing.
 This function is available since SDL 3.2.0.

 If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
 and check the state of the gamepad when you want gamepad information.

 @param enabled : `whether to process gamepad events or not.`
*>
extern fn void set_gamepad_events_enabled(bool enabled) @extern("SDL_SetGamepadEventsEnabled");

<*
 Query the state of gamepad event processing.
 This function is available since SDL 3.2.0.

 If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
 and check the state of the gamepad when you want gamepad information.

 @return `true if gamepad events are being processed, false otherwise.`
*>
extern fn bool gamepad_events_enabled() @extern("SDL_GamepadEventsEnabled");

<*
 Get the SDL joystick layer bindings for a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad.`
 @param count : `a pointer filled in with the number of bindings returned.`
 @return `a NULL terminated array of pointers to bindings or NULL on
          failure; call SDL_GetError() for more information. This is a
          single allocation that should be freed with SDL_free() when it is
          no longer needed.`
*>
extern fn SDLGamepadBinding** SDLGamepad.get_gamepad_bindings(&gamepad, CInt* count) @extern("SDL_GetGamepadBindings");

<*
 Manually pump gamepad updates if not using the loop.
 This function is available since SDL 3.2.0.

 This function is called automatically by the event loop if events are
 enabled. Under such circumstances, it will not be necessary to call this
 function.
*>
extern fn void update_gamepads() @extern("SDL_UpdateGamepads");

<*
 Convert a string into SDL_GamepadType enum.
 This function is available since SDL 3.2.0.

 This function is called internally to translate SDL_Gamepad mapping strings
 for the underlying joystick device into the consistent SDL_Gamepad mapping.
 You do not normally need to call this function unless you are parsing
 SDL_Gamepad mappings in your own code.

 @param str : `string representing a SDL_GamepadType type.`
 @return `the SDL_GamepadType enum corresponding to the input string, or
          'SDL_GAMEPAD_TYPE_UNKNOWN' if no match was found.`
*>
extern fn SDLGamepadType get_gamepad_type_from_string(ZString str) @extern("SDL_GetGamepadTypeFromString");

<*
 Convert from an SDL_GamepadType enum to a string.
 This function is available since SDL 3.2.0.

 @param type : `an enum value for a given SDL_GamepadType.`
 @return `a string for the given type, or NULL if an invalid type is
          specified. The string returned is of the format used by
          SDL_Gamepad mapping strings.`
*>
extern fn ZString get_gamepad_string_from_type(SDLGamepadType type) @extern("SDL_GetGamepadStringForType");

<*
 Convert a string into SDL_GamepadAxis enum.
 This function is available since SDL 3.2.0.

 This function is called internally to translate SDL_Gamepad mapping strings
 for the underlying joystick device into the consistent SDL_Gamepad mapping.
 You do not normally need to call this function unless you are parsing
 SDL_Gamepad mappings in your own code.

 Note specially that "righttrigger" and "lefttrigger" map to
 `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,
 respectively.

 @param str : `string representing a SDL_Gamepad axis.`
 @return `the SDL_GamepadAxis enum corresponding to the input string, or
          'SDL_GAMEPAD_AXIS_INVALID' if no match was found.`
*>
extern fn SDLGamepadAxis get_gamepad_axis_from_string(ZString str) @extern("SDL_GetGamepadAxisFromString");

<*
 Convert from an SDL_GamepadAxis enum to a string.
 This function is available since SDL 3.2.0.

 @param axis : `an enum value for a given SDL_GamepadAxis.`
 @return `a string for the given axis, or NULL if an invalid axis is
          specified. The string returned is of the format used by
          SDL_Gamepad mapping strings.`
*>
extern fn ZString get_gamepad_string_from_axis(SDLGamepadAxis axis) @extern("SDL_GetGamepadStringForAxis");

<*
 Query whether a gamepad has a given axis.
 This function is available since SDL 3.2.0.

 This merely reports whether the gamepad's mapping defined this axis, as
 that is all the information SDL has about the physical device.

 @param gamepad : `a gamepad.`
 @param axis : `an axis enum value (an SDL_GamepadAxis value).`
 @return `true if the gamepad has this axis, false otherwise.`
*>
extern fn bool SDLGamepad.gamepad_has_axis(&gamepad, SDLGamepadAxis axis) @extern("SDL_GamepadHasAxis");

<*
 Get the current state of an axis control on a gamepad.
 This function is available since SDL 3.2.0.

 The axis indices start at index 0.

 For thumbsticks, the state is a value ranging from -32768 (up/left) to
 32767 (down/right).

 Triggers range from 0 when released to 32767 when fully pressed, and never
 return a negative value. Note that this differs from the value reported by
 the lower-level SDL_GetJoystickAxis(), which normally uses the full range.

 @param gamepad : `a gamepad.`
 @param axis : `an axis index (one of the SDL_GamepadAxis values).`
 @return `axis state (including 0) on success or 0 (also) on failure; call
          SDL_GetError() for more information.`
*>
extern fn short SDLGamepad.get_gamepad_axis(&gamepad, SDLGamepadAxis axis) @extern("SDL_GetGamepadAxis");

<*
 Convert a string into an SDL_GamepadButton enum.
 This function is available since SDL 3.2.0.

 This function is called internally to translate SDL_Gamepad mapping strings
 for the underlying joystick device into the consistent SDL_Gamepad mapping.
 You do not normally need to call this function unless you are parsing
 SDL_Gamepad mappings in your own code.

 @param str : `string representing a SDL_Gamepad axis.`
 @return `the SDL_GamepadButton enum corresponding to the input string, or
          'SDL_GAMEPAD_BUTTON_INVALID' if no match was found.`
*>
extern fn SDLGamepadButton get_gamepad_button_from_string(ZString str) @extern("SDL_GetGamepadButtonFromString");

<*
 Convert from an SDL_GamepadButton enum to a string.
 This function is available since SDL 3.2.0.

 @param button : `an enum value for a given SDL_GamepadButton.`
 @return `a string for the given button, or NULL if an invalid button is
          specified. The string returned is of the format used by
          SDL_Gamepad mapping strings.`
*>
extern fn ZString get_gamepad_string_for_button(SDLGamepadButton button) @extern("SDL_GetGamepadStringForButton");

<*
 Query whether a gamepad has a given button.
 This function is available since SDL 3.2.0.

 This merely reports whether the gamepad's mapping defined this button, as
 that is all the information SDL has about the physical device.

 @param gamepad : `a gamepad.`
 @param button : `a button enum value (an SDL_GamepadButton value).`
 @return `true if the gamepad has this button, false otherwise.`
*>
extern fn bool SDLGamepad.gamepad_has_button(&gamepad, SDLGamepadButton button) @extern("SDL_GamepadHasButton");

<*
 Get the current state of a button on a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad :  `a gamepad.`
 @param button : `a button index (one of the SDL_GamepadButton values).`
 @return `true if the button is pressed, false otherwise.`
*>
extern fn bool SDLGamepad.get_gamepad_button(&gamepad, SDLGamepadButton button) @extern("SDL_GetGamepadButton");

<*
 Get the label of a button on a gamepad.
 This function is available since SDL 3.2.0.

 @param type : `the type of gamepad to check.`
 @param button : `a button index (one of the SDL_GamepadButton values).`
 @return `the SDL_GamepadButtonLabel enum corresponding to the button label.`
*>
extern fn SDLGamepadButtonLabel get_gamepad_button_label_for_type(SDLGamepadType type, SDLGamepadButton button) @extern("SDL_GetGamepadButtonLabelForType");

<*
 Get the label of a button on a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad.`
 @param button : `a button index (one of the SDL_GamepadButton values).`
 @return `the SDL_GamepadButtonLabel enum corresponding to the button label.`
*>
extern fn SDLGamepadButtonLabel SDLGamepad.get_gamepad_button_label(&gamepad, SDLGamepadButton button) @extern("SDL_GetGamepadButtonLabel");

<*
 Get the number of touchpads on a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad.`
 @return `number of touchpads.`
*>
extern fn CInt SDLGamepad.get_num_gamepad_touchpads(&gamepad) @extern("SDL_GetNumGamepadTouchpads");

<*
 Get the number of supported simultaneous fingers on a touchpad on a game
 gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad.`
 @param touchpad : `a touchpad.`
 @return `number of supported simultaneous fingers.`
*>
extern fn CInt SDLGamepad.get_num_gamepad_touchpads_fingers(&gamepad, CInt touchpad) @extern("SDL_GetNumGamepadTouchpadFingers");

<*
 Get the current state of a finger on a touchpad on a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `a gamepad.`
 @param touchpad : `a touchpad.`
 @param finger : `a finger.`
 @param down : `a pointer filled with true if the finger is down, false
                otherwise, may be NULL.`
 @param x : `a pointer filled with the x position, normalized 0 to 1, with the
             origin in the upper left, may be NULL.`
 @param y : `a pointer filled with the y position, normalized 0 to 1, with the
             origin in the upper left, may be NULL.`
 @param pressure : `a pointer filled with pressure value, may be NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.get_gamepad_touchpad_finger(&gamepad, CInt touchpad, CInt finger, bool* down, float* x, float* y, float* pressure) @extern("SDL_GetGamepadTouchpadFinger");

<*
 Return whether a gamepad has a particular sensor.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to query.`
 @param type : `the type of sensor to query.`
 @return `true if the sensor exists, false otherwise.`
*>
extern fn bool SDLGamepad.gamepad_has_sensor(&gamepad, SDLSensorType type) @extern("SDL_GamepadHasSensor");

<*
 Set whether data reporting for a gamepad sensor is enabled.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to update.`
 @param type : `the type of sensor to enable/disable.`
 @param enabled : `whether data reporting should be enabled.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.set_gamepad_sensor_enabled(&gamepad, SDLSensorType type, bool enabled) @extern("SDL_SetGamepadSensorEnabled");

<*
 Query whether sensor data reporting is enabled for a gamepad.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to query.`
 @param type : `the type of sensor to query.`
 @return `true if the sensor is enabled, false otherwise.`
*>
extern fn bool SDLGamepad.gamepad_sensor_enabled(&gamepad, SDLSensorType type) @extern("SDL_GamepadSensorEnabled");

<*
 Get the data rate (number of events per second) of a gamepad sensor.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to query.`
 @param type : `the type of sensor to query.`
 @return `the data rate, or 0.0f if the data rate is not available.`
*>
extern fn float SDLGamepad.get_gamepad_sensor_data_rate(&gamepad, SDLSensorType type) @extern("SDL_GetGamepadSensorDataRate");

<*
 Get the current state of a gamepad sensor.
 This function is available since SDL 3.2.0.

 The number of values and interpretation of the data is sensor dependent.
 See SDL_sensor.h for the details for each type of sensor.

 @param gamepad : `the gamepad to query.`
 @param type : `the type of sensor to query.`
 @param data : `a pointer filled with the current sensor state.`
 @param num_values : `the number of values to write to data.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.get_gamepad_sensor_data(&gamepad, SDLSensorType type, float* data, CInt num_values) @extern("SDL_GetGamepadSensorData");

<*
 Start a rumble effect on a gamepad.
 This function is available since SDL 3.2.0.

 Each call to this function cancels any previous rumble effect, and calling
 it with 0 intensity stops any rumbling.

 This function requires you to process SDL events or call
 SDL_UpdateJoysticks() to update rumble state.

 @param gamepad : `the gamepad to vibrate.`
 @param low_frequency_rumble : `the intensity of the low frequency (left)
                                rumble motor, from 0 to 0xFFFF.`
 @param high_frequency_rumble : `the intensity of the high frequency (right)
                                 rumble motor, from 0 to 0xFFFF.`
 @param duration_ms : `the duration of the rumble effect, in milliseconds.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.rumble_gamepad(&gamepad, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms) @extern("SDL_RumbleGamepad");

<*
 Start a rumble effect in the gamepad's triggers.
 This function is available since SDL 3.2.0.

 Each call to this function cancels any previous trigger rumble effect, and
 calling it with 0 intensity stops any rumbling.

 Note that this is rumbling of the _triggers_ and not the gamepad as a
 whole. This is currently only supported on Xbox One gamepads. If you want
 the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.

 This function requires you to process SDL events or call
 SDL_UpdateJoysticks() to update rumble state.

 @param gamepad : `the gamepad to vibrate.`
 @param left_rumble : `the intensity of the left trigger rumble motor, from 0
                       to 0xFFFF.`
 @param right_rumble : `the intensity of the right trigger rumble motor, from 0
                        to 0xFFFF.`
 @param duration_ms : `the duration of the rumble effect, in milliseconds.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.rumble_gamepad_triggers(&gamepad, ushort left_rumble, ushort right_rumble, uint duration_ms) @extern("SDL_RumbleGamepadTriggers");

<*
 Update a gamepad's LED color.
 This function is available since SDL 3.2.0.

 An example of a joystick LED is the light on the back of a PlayStation 4's
 DualShock 4 controller.

 For gamepads with a single color LED, the maximum of the RGB values will be
 used as the LED brightness.

 @param gamepad : `the gamepad to update.`
 @param red : `the intensity of the red LED.`
 @param green : `the intensity of the green LED.`
 @param blue : `the intensity of the blue LED.`
 @eeturn `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.set_gamepad_led(&gamepad, char red, char green, char blue) @extern("SDL_SetGamepadLED");

<*
 Send a gamepad specific effect packet.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to affect.`
 @param data : `the data to send to the gamepad.`
 @param size : `the size of the data to send to the gamepad.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGamepad.set_gamepad_effect(&gamepad, void* data, CInt size) @extern("SDL_SendGamepadEffect");

<*
 Close a gamepad previously opened with SDL_OpenGamepad().

 @param gamepad : `a gamepad identifier previously returned by
                   SDL_OpenGamepad().`
*>
extern fn void SDLGamepad.close_gamepad(&gamepad) @extern("SDL_CloseGamepad");

<*
 Return the sfSymbolsName for a given button on a gamepad on Apple
 platforms.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to query.`
 @param button : `a button on the gamepad.`
 @return `the sfSymbolsName or NULL if the name can't be found.`
*>
extern fn ZString SDLGamepad.get_gamepad_apple_sf_symbols_name_for_button(&gamepad, SDLGamepadButton button) @extern("SDL_GetGamepadAppleSFSymbolsNameForButton");

<*
 Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.
 This function is available since SDL 3.2.0.

 @param gamepad : `the gamepad to query.`
 @param axis : `an axis on the gamepad.`
 @return `the sfSymbolsName or NULL if the name can't be found.`
*>
extern fn ZString SDLGamepad.get_gamepad_apple_sf_symbols_name_for_axis(&gamepad, SDLGamepadAxis axis) @extern("SDL_GetGamepadAppleSFSymbolsNameForAxis");
