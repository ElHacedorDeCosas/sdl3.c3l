<*
 Event queue management.

 It's extremely common--often required--that an app deal with SDL's event
 queue. Almost all useful information about interactions with the real world
 flow through here: the user interacting with the computer and app, hardware
 coming and going, the system changing in some way, etc.

 An app generally takes a moment, perhaps at the start of a new frame, to
 examine any events that have occured since the last time and process or
 ignore them. This is generally done by calling SDL_PollEvent() in a loop
 until it returns false (or, if using the main callbacks, events are
 provided one at a time in calls to SDL_AppEvent() before the next call to
 SDL_AppIterate(); in this scenario, the app does not call SDL_PollEvent()
 at all).

 There is other forms of control, too: SDL_PeepEvents() has more
 functionality at the cost of more complexity, and SDL_WaitEvent() can block
 the process until something interesting happens, which might be beneficial
 for certain types of programs on low-power hardware. One may also call
 SDL_AddEventWatch() to set a callback when new events arrive.

 The app is free to generate their own events, too: SDL_PushEvent allows the
 app to put events onto the queue for later retrieval; SDL_RegisterEvents
 can guarantee that these events have a type that isn't in use by other
 parts of the system.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryEvents
*>
module sdl;

/* General keyboard/mouse/pen state definitions */

<*
 The types of events that can be delivered.
 This enum is available since SDL 3.2.0.
*>
enum SDLEventType : const uint
{
    FIRST     = 0,     // Unused (do not remove)

    // Application events
    QUIT      = 0x100, // User-requested quit

    // These application events have special meaning on iOS and Android, see README-ios.md and README-android.md for details
    TERMINATING,      // The application is being terminated by the OS. This event must be handled in a callback set with SDL_AddEventWatch().
                      //               Called on iOS in applicationWillTerminate()
                      //               Called on Android in onDestroy()

    LOW_MEMORY,       // The application is low on memory, free memory if possible. This event must be handled in a callback set with SDL_AddEventWatch().
                      //               Called on iOS in applicationDidReceiveMemoryWarning()
                      //               Called on Android in onTrimMemory()

    WILL_ENTER_BACKGROUND, // The application is about to enter the background. This event must be handled in a callback set with SDL_AddEventWatch().
                           //             Called on iOS in applicationWillResignActive()
                           //             Called on Android in onPause()

    DID_ENTER_BACKGROUND, // The application did enter the background and may not get CPU for some time. This event must be handled in a callback set with SDL_AddEventWatch().
                          //           Called on iOS in applicationDidEnterBackground()
                          //           Called on Android in onPause()

    WILL_ENTER_FOREGROUND, // The application is about to enter the foreground. This event must be handled in a callback set with SDL_AddEventWatch().
                           //          Called on iOS in applicationWillEnterForeground()
                           //          Called on Android in onResume()

    DID_ENTER_FOREGROUND, // The application is now interactive. This event must be handled in a callback set with SDL_AddEventWatch().
                          //           Called on iOS in applicationDidBecomeActive()
                          //           Called on Android in onResume()


    LOCALE_CHANGED,  // The user's locale preferences have changed.

    SYSTEM_THEME_CHANGED, // The system theme changed

    // Display events
    // 0x150 was SDL_DISPLAYEVENT, reserve the number for sdl2-compat
    DISPLAY_ORIENTATION = 0x151,   // Display orientation has changed to data1
    DISPLAY_ADDED,                 // Display has been added to the system
    DISPLAY_REMOVED,               // Display has been removed from the system
    DISPLAY_MOVED,                 // Display has changed position
    DISPLAY_DESKTOP_MODE_CHANGED,  // Display has changed desktop mode
    DISPLAY_CURRENT_MODE_CHANGED,  // Display has changed current mode
    DISPLAY_CONTENT_SCALE_CHANGED, // Display has changed content scale
    DISPLAY_FIRST = DISPLAY_ORIENTATION,
    DISPLAY_LAST = DISPLAY_CONTENT_SCALE_CHANGED,

    // Window events
    // 0x200 was SDL_WINDOWEVENT, reserve the number for sdl2-compat
    // 0x201 was SDL_SYSWMEVENT, reserve the number for sdl2-compat
    WINDOW_SHOWN = 0x202,     // Window has been shown
    WINDOW_HIDDEN,            // Window has been hidden
    WINDOW_EXPOSED,           // Window has been exposed and should be redrawn, and can be redrawn directly from event watchers for this event
    WINDOW_MOVED,             // Window has been moved to data1, data2
    WINDOW_RESIZED,           // Window has been resized to data1xdata2
    WINDOW_PIXEL_SIZE_CHANGED,// The pixel size of the window has changed to data1xdata2
    WINDOW_METAL_VIEW_RESIZED,// The pixel size of a Metal view associated with the window has changed
    WINDOW_MINIMIZED,         // Window has been minimized
    WINDOW_MAXIMIZED,         // Window has been maximized
    WINDOW_RESTORED,          // Window has been restored to normal size and position
    WINDOW_MOUSE_ENTER,       // Window has gained mouse focus
    WINDOW_MOUSE_LEAVE,       // Window has lost mouse focus
    WINDOW_FOCUS_GAINED,      // Window has gained keyboard focus
    WINDOW_FOCUS_LOST,        // Window has lost keyboard focus
    WINDOW_CLOSE_REQUESTED,   // The window manager requests that the window be closed
    WINDOW_HIT_TEST,          // Window had a hit test that wasn't SDL_HITTEST_NORMAL
    WINDOW_ICCPROF_CHANGED,   // The ICC profile of the window's display has changed
    WINDOW_DISPLAY_CHANGED,   // Window has been moved to display data1
    WINDOW_DISPLAY_SCALE_CHANGED, // Window display scale has been changed
    WINDOW_SAFE_AREA_CHANGED, // The window safe area has been changed
    WINDOW_OCCLUDED,          // The window has been occluded
    WINDOW_ENTER_FULLSCREEN,  // The window has entered fullscreen mode
    WINDOW_LEAVE_FULLSCREEN,  // The window has left fullscreen mode
    WINDOW_DESTROYED,         // The window with the associated ID is being or has been destroyed. If this message is being handled
                              //             in an event watcher, the window handle is still valid and can still be used to retrieve any properties
                              //             associated with the window. Otherwise, the handle has already been destroyed and all resources
                              //             associated with it are invalid
    WINDOW_HDR_STATE_CHANGED, // Window HDR properties have changed
    WINDOW_FIRST = WINDOW_SHOWN,
    WINDOW_LAST = WINDOW_HDR_STATE_CHANGED,

    // Keyboard events
    KEY_DOWN        = 0x300, // Key pressed
    KEY_UP,                  // Key released
    TEXT_EDITING,            // Keyboard text editing (composition)
    TEXT_INPUT,              // Keyboard text input
    KEYMAP_CHANGED,          // Keymap changed due to a system event such as an
                             //             input language or keyboard layout change.
    KEYBOARD_ADDED,          // A new keyboard has been inserted into the system
    KEYBOARD_REMOVED,        // A keyboard has been removed
    TEXT_EDITING_CANDIDATES, // Keyboard text editing candidates

    // Mouse events
    MOUSE_MOTION    = 0x400, // Mouse moved
    MOUSE_BUTTON_DOWN,       // Mouse button pressed
    MOUSE_BUTTON_UP,         // Mouse button released
    MOUSE_WHEEL,             // Mouse wheel motion
    MOUSE_ADDED,             // A new mouse has been inserted into the system
    MOUSE_REMOVED,           // A mouse has been removed

    // Joystick events
    JOYSTICK_AXIS_MOTION  = 0x600, // Joystick axis motion
    JOYSTICK_BALL_MOTION,          // Joystick trackball motion
    JOYSTICK_HAT_MOTION,           // Joystick hat position change
    JOYSTICK_BUTTON_DOWN,          // Joystick button pressed
    JOYSTICK_BUTTON_UP,            // Joystick button released
    JOYSTICK_ADDED,                // A new joystick has been inserted into the system
    JOYSTICK_REMOVED,              // An opened joystick has been removed
    JOYSTICK_BATTERY_UPDATED,      // Joystick battery level change
    JOYSTICK_UPDATE_COMPLETE,      // Joystick update is complete

    // Gamepad events
    GAMEPAD_AXIS_MOTION  = 0x650, // Gamepad axis motion
    GAMEPAD_BUTTON_DOWN,          // Gamepad button pressed
    GAMEPAD_BUTTON_UP,            // Gamepad button released
    GAMEPAD_ADDED,                // A new gamepad has been inserted into the system
    GAMEPAD_REMOVED,              // A gamepad has been removed
    GAMEPAD_REMAPPED,             // The gamepad mapping was updated
    GAMEPAD_TOUCHPAD_DOWN,        // Gamepad touchpad was touched
    GAMEPAD_TOUCHPAD_MOTION,      // Gamepad touchpad finger was moved
    GAMEPAD_TOUCHPAD_UP,          // Gamepad touchpad finger was lifted
    GAMEPAD_SENSOR_UPDATE,        // Gamepad sensor was updated
    GAMEPAD_UPDATE_COMPLETE,      // Gamepad update is complete
    GAMEPAD_STEAM_HANDLE_UPDATED, // Gamepad Steam handle has changed

    // Touch events
    FINGER_DOWN      = 0x700,
    FINGER_UP,
    FINGER_MOTION,
    FINGER_CANCELED,

    // 0x800, 0x801, and 0x802 were the Gesture events from SDL2. Do not reuse these values! sdl2-compat needs them!

    // Clipboard events
    CLIPBOARD_UPDATE = 0x900, // The clipboard or primary selection changed

    // Drag and drop events
    DROP_FILE        = 0x1000, // The system requests a file open
    DROP_TEXT,                 // text/plain drag-and-drop event
    DROP_BEGIN,                // A new set of drops is beginning (NULL filename)
    DROP_COMPLETE,             // Current set of drops is now complete (NULL filename)
    DROP_POSITION,             // Position while moving over the window

    // Audio hotplug events
    AUDIO_DEVICE_ADDED = 0x1100,  // A new audio device is available
    AUDIO_DEVICE_REMOVED,         // An audio device has been removed.
    AUDIO_DEVICE_FORMAT_CHANGED,  // An audio device's format has been changed by the system.

    // Sensor events
    SENSOR_UPDATE = 0x1200,     // A sensor was updated

    // Pressure-sensitive pen events
    PEN_PROXIMITY_IN = 0x1300,  // Pressure-sensitive pen has become available
    PEN_PROXIMITY_OUT,          // Pressure-sensitive pen has become unavailable
    PEN_DOWN,                   // Pressure-sensitive pen touched drawing surface
    PEN_UP,                     // Pressure-sensitive pen stopped touching drawing surface
    PEN_BUTTON_DOWN,            // Pressure-sensitive pen button pressed
    PEN_BUTTON_UP,              // Pressure-sensitive pen button released
    PEN_MOTION,                 // Pressure-sensitive pen is moving on the tablet
    PEN_AXIS,                   // Pressure-sensitive pen angle/pressure/etc changed

    // Camera hotplug events
    CAMERA_DEVICE_ADDED = 0x1400,  // A new camera device is available
    CAMERA_DEVICE_REMOVED,         // A camera device has been removed.
    CAMERA_DEVICE_APPROVED,        // A camera device has been approved for use by the user.
    CAMERA_DEVICE_DENIED,          // A camera device has been denied for use by the user.

    // Render events
    RENDER_TARGETS_RESET = 0x2000, // The render targets have been reset and their contents need to be updated
    RENDER_DEVICE_RESET, // The device has been reset and all textures need to be recreated
    RENDER_DEVICE_LOST, // The device has been lost and can't be recovered.

    // Reserved events for private platforms
    PRIVATE0 = 0x4000,
    PRIVATE1,
    PRIVATE2,
    PRIVATE3,

    // Internal events
    POLL_SENTINEL = 0x7F00, // Signals the end of an event poll cycle

    // Events USER through LAST are for your use,
    //  and should be allocated with SDL_RegisterEvents()

    USER    = 0x8000,

    // This last event is only for bounding internal arrays

    LAST    = 0xFFFF,

    // This just makes sure the enum is the size of uint
    ENUM_PADDING = 0x7FFFFFFF
}

<*
 Fields shared by every event
 This struct is available since SDL 3.2.0.
*>
struct SDLCommonEvent
{
    uint  type;        // Event type, shared with all events, uint to cover user events which are not in the SDL_EventType enumeration
    uint  reserved;
    ulong timestamp;   // In nanoseconds, populated using SDL_GetTicksNS()
}

<*
 Display state change event data (event.display.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLDisplayEvent
{
	inline SDLCommonEvent common; // SDL_DISPLAYEVENT_*
    SDLDisplayID display_id;      // The associated display
    int data1;                    // event dependent data
    int data2;                    // event dependent data
}

<*
 Window state change event data (event.window.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLWindowEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_WINDOW_*
    SDLWindowID window_id;        // The associated window
    int data1;                    // event dependent data
    int data2;                    // event dependent data
}

<*
 Keyboard device event structure (event.kdevice.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLKeyboardDeviceEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_KEYBOARD_ADDED or SDL_EVENT_KEYBOARD_REMOVED
    SDLKeyboardID which;          // The keyboard instance id
}

<*
 Keyboard button event structure (event.key.*)
 This struct is available since SDL 3.2.0.

 The `key` is the base SDL_Keycode generated by pressing the `scancode`
 using the current keyboard layout, applying any options specified in
 SDL_HINT_KEYCODE_OPTIONS. You can get the SDL_Keycode corresponding to the
 event scancode and modifiers directly from the keyboard layout, bypassing
 SDL_HINT_KEYCODE_OPTIONS, by calling SDL_GetKeyFromScancode().
*>
struct SDLKeyboardEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_KEY_DOWN or SDL_EVENT_KEY_UP
    SDLWindowID window_id;        // The window with keyboard focus, if any
    SDLKeyboardID which;          // The keyboard instance id, or 0 if unknown or virtual
    SDLScancode scancode;         // SDL physical key code
    SDLKeycode key;               // SDL virtual key code
    SDLKeymod mod;                // current key modifiers
    ushort raw;                   // The platform dependent scancode for this event
    bool down;                    // true if the key is pressed
    bool repeat;                  // true if this is a key repeat
}

<*
 Keyboard text editing event structure (event.edit.*)
 This struct is available since SDL 3.2.0.

 The start cursor is the position, in UTF-8 characters, where new typing
 will be inserted into the editing text. The length is the number of UTF-8
 characters that will be replaced by new typing.
*>
struct SDLTextEditingEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_TEXT_EDITING
    SDLWindowID window_id;        // The window with keyboard focus, if any
    ZString text;                 // The editing text
    int start;                    // The start cursor of selected editing text, or -1 if not set
    int length;                   // The length of selected editing text, or -1 if not set
}

<*
 Keyboard IME candidates event structure (event.edit_candidates.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLTextEditingCandidatesEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_TEXT_EDITING_CANDIDATES
    SDLWindowID window_id;        // The window with keyboard focus, if any
    ZString* candidates;        // The list of candidates, or NULL if there are no candidates available
    int num_candidates;         // The number of strings in `candidates`
    int selected_candidate;     // The index of the selected candidate, or -1 if no candidate is selected
    bool horizontal;            // true if the list is horizontal, false if it's vertical
    char padding1;
    char padding2;
    char padding3;
}

<*
 Keyboard text input event structure (event.text.*)
 This struct is available since SDL 3.2.0.

 This event will never be delivered unless text input is enabled by calling
 SDL_StartTextInput(). Text input is disabled by default!
*>
struct SDLTextInputEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_TEXT_INPUT
    SDLWindowID window_id;        // The window with keyboard focus, if any
    ZString text;                 // The input text, UTF-8 encoded
}

<*
 Mouse device event structure (event.mdevice.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLMouseDeviceEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_MOUSE_ADDED or SDL_EVENT_MOUSE_REMOVED
    SDLMouseID which;             // The mouse instance id
}

<*
 Mouse motion event structure (event.motion.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLMouseMotionEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_MOUSE_MOTION
    SDLWindowID window_id;        // The window with mouse focus, if any
    SDLMouseID which;             // The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0
    SDLMouseButtonFlags state;    // The current button state
    float x;                      // X coordinate, relative to window
    float y;                      // Y coordinate, relative to window
    float xrel;                   // The relative motion in the X direction
    float yrel;                   // The relative motion in the Y direction
}

<*
 Mouse button event structure (event.button.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLMouseButtonEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_MOUSE_MOTION
    SDLWindowID window_id;        // The window with mouse focus, if any
    SDLMouseID which;             // The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0
    char button;                  // The mouse button index
    bool down;                    // true if the button is pressed
    char clicks;                  // 1 for single-click, 2 for double-click, etc.
    char padding;
    float x;                      // X coordinate, relative to window
    float y;                      // Y coordinate, relative to window
}

<*
 Mouse wheel event structure (event.wheel.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLMouseWheelEvent
{
    inline SDLCommonEvent common;     // SDL_EVENT_MOUSE_WHEEL
    SDLWindowID window_id;            // The window with mouse focus, if any
    SDLMouseID which;                 // The mouse instance id in relative mode or 0
    float x;                          // The amount scrolled horizontally, positive to the right and negative to the left
    float y;                          // The amount scrolled vertically, positive away from the user and negative toward the user
    SDLMouseWheelDirection direction; // Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back
    float mouse_x;                    // X coordinate, relative to window
    float mouse_y;                    // Y coordinate, relative to window
    int integer_x;                    // The amount scrolled horizontally, accumulated to whole scroll "ticks" (added in 3.2.12)
    int integer_y;                    // The amount scrolled vertically, accumulated to whole scroll "ticks" (added in 3.2.12)
}

<*
 Joystick axis motion event structure (event.jaxis.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLJoyAxisEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_JOYSTICK_AXIS_MOTION
    SDLJoystickID which;          // The joystick instance id
    char axis;                    // The joystick axis index
    char padding1;
    char padding2;
    char padding3;
    short value;                  // The axis value (range: -32768 to 32767)
    ushort padding4;
}

<*
 Joystick trackball motion event structure (event.jball.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLJoyBallEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_JOYSTICK_BALL_MOTION
    SDLJoystickID which;          // The joystick instance id
    char ball;                    // The joystick trackball index
    char padding1;
    char padding2;
    char padding3;
    short xrel;                   // The relative motion in the X direction
    short yrel;                   // The relative motion in the Y direction
}

<*
 Joystick hat position change event structure (event.jhat.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLJoyHatEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_JOYSTICK_HAT_MOTION
    SDLJoystickID which;          // The joystick instance id
    char hat;                     // The joystick hat index
    char value;                   // The hat position value.
                                  // SDL_HAT_LEFTUP SDL_HAT_UP SDL_HAT_RIGHTUP
                                  // SDL_HAT_LEFT SDL_HAT_CENTERED SDL_HAT_RIGHT
                                  // SDL_HAT_LEFTDOWN SDL_HAT_DOWN SDL_HAT_RIGHTDOWN
                                  // Note that zero means the POV is centered.
    char padding1;
    char padding2;
}

<*
 Joystick button event structure (event.jbutton.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLJoyButtonEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_JOYSTICK_BUTTON_DOWN or SDL_EVENT_JOYSTICK_BUTTON_UP
    SDLJoystickID which;          // The joystick instance id
    char button;                  // The joystick button index
    bool down;                    // true if the button is pressed
    char padding1;
    char padding2;
}

<*
 Joystick device event structure (event.jdevice.*)
 This struct is available since SDL 3.2.0.

 SDL will send JOYSTICK_ADDED events for devices that are already plugged in
 during SDL_Init.
*>
struct SDLJoyDeviceEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_JOYSTICK_ADDED or SDL_EVENT_JOYSTICK_REMOVED or SDL_EVENT_JOYSTICK_UPDATE_COMPLETE
    SDLJoystickID which;          // The joystick instance id
}

<*
 Joystick battery level change event structure (event.jbattery.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLJoyBatteryEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_JOYSTICK_BATTERY_UPDATED
    SDLJoystickID which;         // The joystick instance id
    SDLPowerState state;          // The joystick battery state
    int percent;                  // The joystick battery percent charge remaining
}

<*
 Gamepad axis motion event structure (event.gaxis.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLGamepadAxisEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_GAMEPAD_AXIS_MOTION
    SDLJoystickID which;         // The joystick instance id
    char axis;                    // The gamepad axis (SDLGamepadAxis)
    char padding1;
    char padding2;
    char padding3;
    short value;                  // The axis value (range: -32768 to 32767)
    ushort padding4;
}

<*
 Gamepad button event structure (event.gbutton.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLGamepadButtonEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_GAMEPAD_BUTTON_DOWN or SDL_EVENT_GAMEPAD_BUTTON_UP
    SDLJoystickID which;          // The joystick instance id
    char button;                  // The gamepad button (SDL_GamepadButton)
    bool down;                    // true if the button is pressed
    char padding1;
    char padding2;
}

<*
 Gamepad device event structure (event.gdevice.*)
 This struct is available since SDL 3.2.0.

 Joysticks that are supported gamepads receive both an SDL_JoyDeviceEvent
 and an SDL_GamepadDeviceEvent.

 SDL will send GAMEPAD_ADDED events for joysticks that are already plugged
 in during SDL_Init() and are recognized as gamepads. It will also send
 events for joysticks that get gamepad mappings at runtime.
*>
struct SDLGamepadDeviceEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_GAMEPAD_ADDED, SDL_EVENT_GAMEPAD_REMOVED, or SDL_EVENT_GAMEPAD_REMAPPED, SDL_EVENT_GAMEPAD_UPDATE_COMPLETE or SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED
    SDLJoystickID which;          // The joystick instance id
}

<*
 Gamepad touchpad event structure (event.gtouchpad.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLGamepadTouchpadEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN or SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION or SDL_EVENT_GAMEPAD_TOUCHPAD_UP
    SDLJoystickID which;          // The joystick instance id
    int touchpad;                 // The index of the touchpad
    int finger;                   // The index of the finger on the touchpad
    float x;                      // Normalized in the range 0...1 with 0 being on the left
    float y;                      // Normalized in the range 0...1 with 0 being at the top
    float pressure;               // Normalized in the range 0...1
}

<*
 Gamepad sensor event structure (event.gsensor.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLGamepadSensorEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_GAMEPAD_SENSOR_UPDATE
    SDLJoystickID which;          // The joystick instance id
    int sensor;                   // The type of the sensor, one of the values of SDLSensorType
    float[3] data;                // Up to 3 values from the sensor, as defined in sdl3_sensor.c3i
    ulong sensor_timestamp;       // The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock
}

<*
 Audio device event structure (event.adevice.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLAudioDeviceEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_AUDIO_DEVICE_ADDED, or SDL_EVENT_AUDIO_DEVICE_REMOVED, or SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED
    SDLAudioDeviceID which;       // SDLAudioDeviceID for the device being added or removed or changing
    bool recording;               // false if a playback device, true if a recording device.
    char padding1;
    char padding2;
    char padding3;
}

<*
 Camera device event structure (event.cdevice.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLCameraDeviceEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_CAMERA_DEVICE_ADDED, SDL_EVENT_CAMERA_DEVICE_REMOVED, SDL_EVENT_CAMERA_DEVICE_APPROVED, SDL_EVENT_CAMERA_DEVICE_DENIED
    SDLCameraID which;            // SDLCameraID for the device being added or removed or changing
}

<*
 Renderer event structure (event.render.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLRenderEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_RENDER_TARGETS_RESET, SDL_EVENT_RENDER_DEVICE_RESET, SDL_EVENT_RENDER_DEVICE_LOST
    SDLWindowID window_id;        // The window containing the renderer in question.
}

<*
 Touch finger event structure (event.tfinger.*)
 This struct is available since SDL 3.2.0.

 Coordinates in this event are normalized. `x` and `y` are normalized to a
 range between 0.0f and 1.0f, relative to the window, so (0,0) is the top
 left and (1,1) is the bottom right. Delta coordinates `dx` and `dy` are
 normalized in the ranges of -1.0f (traversed all the way from the bottom or
 right to all the way up or left) to 1.0f (traversed all the way from the
 top or left to all the way down or right).

 Note that while the coordinates are _normalized_, they are not _clamped_,
 which means in some circumstances you can get a value outside of this
 range. For example, a renderer using logical presentation might give a
 negative value when the touch is in the letterboxing. Some platforms might
 report a touch outside of the window, which will also be outside of the
 range.
*>
struct SDLTouchFingerEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_FINGER_DOWN, SDL_EVENT_FINGER_UP, SDL_EVENT_FINGER_MOTION, or SDL_EVENT_FINGER_CANCELED
    SDLTouchID touch_id;          // The touch device id
    SDLFingerID finger_id;
    float x;                      // Normalized in the range 0...1
    float y;                      // Normalized in the range 0...1
    float dx;                     // Normalized in the range -1...1
    float dy;                     // Normalized in the range -1...1
    float pressure;               // Normalized in the range 0...1
    SDLWindowID window_id;        // The window underneath the finger, if any
}

<*
 Pressure-sensitive pen proximity event structure (event.pmotion.*)
 This struct is available since SDL 3.2.0.

 When a pen becomes visible to the system (it is close enough to a tablet,
 etc), SDL will send an SDL_EVENT_PEN_PROXIMITY_IN event with the new pen's
 ID. This ID is valid until the pen leaves proximity again (has been removed
 from the tablet's area, the tablet has been unplugged, etc). If the same
 pen reenters proximity again, it will be given a new ID.

 Note that "proximity" means "close enough for the tablet to know the tool
 is there." The pen touching and lifting off from the tablet while not
 leaving the area are handled by SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP.
*>
struct SDLPenProximityEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_PEN_PROXIMITY_IN or SDL_EVENT_PEN_PROXIMITY_OUT
    SDLWindowID window_id;        // The window with pen focus, if any
    SDLPenID which;               // The pen instance id
}

<*
 Pressure-sensitive pen motion event structure (event.pmotion.*)
 This struct is available since SDL 3.2.0.

 Depending on the hardware, you may get motion events when the pen is not
 touching a tablet, for tracking a pen even when it isn't drawing. You
 should listen for SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP events, or check
 `pen_state & SDL_PEN_INPUT_DOWN` to decide if a pen is "drawing" when
 dealing with pen motion.
*>
struct SDLPenMotionEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_PEN_MOTION
    SDLWindowID window_id;        // The window with pen focus, if any
    SDLPenID which;               // The pen instance id
    SDLPenInputFlags pen_state;   // Complete pen input state at time of event
    float x;                      // X coordinate, relative to window
    float y;                      // Y coordinate, relative to window
}

<*
 Pressure-sensitive pen touched event structure (event.ptouch.*)
 This struct is available since SDL 3.2.0.

 These events come when a pen touches a surface (a tablet, etc), or lifts
 off from one.
*>
struct SDLPenTouchEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_PEN_DOWN or SDL_EVENT_PEN_UP
    SDLWindowID window_id;        // The window with pen focus, if any
    SDLPenID which;               // The pen instance id
    SDLPenInputFlags pen_state;   // Complete pen input state at time of event
    float x;                      // X coordinate, relative to window
    float y;                      // Y coordinate, relative to window
    bool eraser;                  // true if eraser end is used (not all pens support this).
    bool down;                    // true if the pen is touching or false if the pen is lifted off
}

<*
 Pressure-sensitive pen button event structure (event.pbutton.*)
 This struct is available since SDL 3.2.0.

 This is for buttons on the pen itself that the user might click. The pen
 itself pressing down to draw triggers a SDL_EVENT_PEN_DOWN event instead.
*>
struct SDLPenButtonEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_PEN_BUTTON_DOWN or SDL_EVENT_PEN_BUTTON_UP
    SDLWindowID window_id;        // The window with pen focus, if any
    SDLPenID which;               // The pen instance id
    SDLPenInputFlags pen_state;   // Complete pen input state at time of event
    float x;                      // X coordinate, relative to window
    float y;                      // Y coordinate, relative to window
    char button;                  // The pen button index (first button is 1).
    bool down;                    // true if the button is pressed
}

<*
 Pressure-sensitive pen pressure / angle event structure (event.paxis.*)
 This struct is available since SDL 3.2.0.

 You might get some of these events even if the pen isn't touching the
 tablet.
*>
struct SDLPenAxisEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_PEN_AXIS
    SDLWindowID window_id;        // The window with pen focus, if any
    SDLPenID which;               // The pen instance id
    SDLPenInputFlags pen_state;   // Complete pen input state at time of event
    float x;                      // X coordinate, relative to window
    float y;                      // Y coordinate, relative to window
    SDLPenAxis axis;              // Axis that has changed
    float value;                  // New value of axis
}

<*
 An event used to drop text or request a file open by the system
 (event.drop.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLDropEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_DROP_BEGIN or SDL_EVENT_DROP_FILE or SDL_EVENT_DROP_TEXT or SDL_EVENT_DROP_COMPLETE or SDL_EVENT_DROP_POSITION
    SDLWindowID window_id;        // The window that was dropped on, if any
    float x;                      // X coordinate, relative to window (not on begin)
    float y;                      // Y coordinate, relative to window (not on begin)
    ZString source;               // The source app that sent this drop event, or NULL if that isn't available
    ZString data;                 // The text for SDL_EVENT_DROP_TEXT and the file name for SDL_EVENT_DROP_FILE, NULL for other events
}

<*
 An event triggered when the clipboard contents have changed
 (event.clipboard.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLClipboardEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_CLIPBOARD_UPDATE
    bool owner;                   // are we owning the clipboard (internal update)
    int num_mime_types;           // number of mime types
    ZString* mime_types;          // current mime types
}

<*
 Sensor event structure (event.sensor.*)
 This struct is available since SDL 3.2.0.
*>
struct SDLSensorEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_SENSOR_UPDATE
    SDLSensorID which;            // The instance ID of the sensor
    float[6] data;                // Up to 6 values from the sensor - additional values can be queried using SDL_GetSensorData()
    ulong sensor_timestamp;       // The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock
}

<*
 The "quit requested" event
 This struct is available since SDL 3.2.0.
*>
struct SDLQuitEvent
{
    inline SDLCommonEvent common; // SDL_EVENT_QUIT
}

<*
 A user-defined event type (event.user.*)
 This struct is available since SDL 3.2.0.

 This event is unique; it is never created by SDL, but only by the
 application. The event can be pushed onto the event queue using
 SDL_PushEvent(). The contents of the structure members are completely up to
 the programmer; the only requirement is that '''type''' is a value obtained
 from SDL_RegisterEvents().
*>
struct SDLUserEvent
{
	inline SDLCommonEvent common; // SDL_EVENT_USER through SDL_EVENT_LAST-1, uint because these are not in the SDL_EventType enumeration
	SDLWindowID window_id;        // The associated window if any
    int code;                     // User defined event code
    void* data1;                  // User defined data pointer
    void* data2;                  // User defined data pointer
}

<*
 The structure for all events in SDL.
 This struct is available since SDL 3.2.0.

 The SDL_Event structure is the core of all event handling in SDL. SDL_Event
 is a union of all event structures used in SDL.
*>
union SDLEvent
{
    SDLEventType type;                             // Event type, shared with all events, uint to cover user events which are not in the SDL_EventType enumeration
    SDLCommonEvent common;                 // Common event data
    SDLDisplayEvent display;               // Display event data
    SDLWindowEvent window;                 // Window event data
    SDLKeyboardDeviceEvent kdevice;        // Keyboard device change event data
    SDLKeyboardEvent key;                  // Keyboard event data
    SDLTextEditingEvent edit;              // Text editing event data
    SDLTextEditingCandidatesEvent edit_candidates; // Text editing candidates event data
    SDLTextInputEvent text;                // Text input event data
    SDLMouseDeviceEvent mdevice;           // Mouse device change event data
    SDLMouseMotionEvent motion;            // Mouse motion event data
    SDLMouseButtonEvent button;            // Mouse button event data
    SDLMouseWheelEvent wheel;              // Mouse wheel event data
    SDLJoyDeviceEvent jdevice;             // Joystick device change event data
    SDLJoyAxisEvent jaxis;                 // Joystick axis event data
    SDLJoyBallEvent jball;                 // Joystick ball event data
    SDLJoyHatEvent jhat;                   // Joystick hat event data
    SDLJoyButtonEvent jbutton;             // Joystick button event data
    SDLJoyBatteryEvent jbattery;           // Joystick battery event data
    SDLGamepadDeviceEvent gdevice;         // Gamepad device event data
    SDLGamepadAxisEvent gaxis;             // Gamepad axis event data
    SDLGamepadButtonEvent gbutton;         // Gamepad button event data
    SDLGamepadTouchpadEvent gtouchpad;     // Gamepad touchpad event data
    SDLGamepadSensorEvent gsensor;         // Gamepad sensor event data
    SDLAudioDeviceEvent adevice;           // Audio device event data
    SDLCameraDeviceEvent cdevice;          // Camera device event data
    SDLSensorEvent sensor;                 // Sensor event data
    SDLQuitEvent quit;                     // Quit request event data
    SDLUserEvent user;                     // Custom event data
    SDLTouchFingerEvent tfinger;           // Touch finger event data
    SDLPenProximityEvent pproximity;       // Pen proximity event data
    SDLPenTouchEvent ptouch;               // Pen tip touching event data
    SDLPenMotionEvent pmotion;             // Pen motion event data
    SDLPenButtonEvent pbutton;             // Pen button event data
    SDLPenAxisEvent paxis;                 // Pen axis event data
    SDLRenderEvent render;                 // Render event data
    SDLDropEvent drop;                     // Drag and drop event data
    SDLClipboardEvent clipboard;           // Clipboard event data
    char[128] padding;
}

/* Make sure we haven't broken binary compatibility */
$assert(SDLEvent.sizeof == SDLEvent.padding.sizeof);

<*
 Pump the event loop, gathering events from the input devices.
 This function is available since SDL 3.2.0.

 This function updates the event queue and internal input device state.

 SDL_PumpEvents() gathers all the pending input information from devices and
 places it in the event queue. Without calls to SDL_PumpEvents() no events
 would ever be placed on the queue. Often the need for calls to
 SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
 SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
 polling or waiting for events (e.g. you are filtering them), then you must
 call SDL_PumpEvents() to force an event queue update.

 threadsafety: This function should only be called on the main thread.
*>
extern fn void pump_events() @extern("SDL_PumpEvents");

<*
 The type of action to request from SDL_PeepEvents().
 This enum is available since SDL 3.2.0.
*>
enum SDLEventAction
{
    ADDEVENT,  // Add events to the back of the queue.
    PEEKEVENT, // Check but don't remove events from the queue front.
    GETEVENT   // Retrieve/remove events from the front of the queue.
}

<*
 Check the event queue for messages and optionally return them.
 This function is available since SDL 3.2.0.

 `action` may be any of the following:

 - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
   event queue.
 - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
   within the specified minimum and maximum type, will be returned to the
   caller and will _not_ be removed from the queue. If you pass NULL for
   `events`, then `numevents` is ignored and the total number of matching
   events will be returned.
 - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
   within the specified minimum and maximum type, will be returned to the
   caller and will be removed from the queue.

 You may have to call SDL_PumpEvents() before calling this function.
 Otherwise, the events may not be ready to be filtered when you call
 SDL_PeepEvents().

 threadsafety: It is safe to call this function from any thread.

 @param events : `destination buffer for the retrieved events, may be NULL to
                  leave the events in the queue and return the number of events
                  that would have been stored.`
 @param num_events : `if action is SDL_ADDEVENT, the number of events to add
                      back to the event queue; if action is SDL_PEEKEVENT or
                      SDL_GETEVENT, the maximum number of events to retrieve.`
 @param action : `action to take; see [Remarks](#remarks) for details.`
 @param min_type : `minimum value of the event type to be considered;
                    SDL_EVENT_FIRST is a safe choice.`
 @param max_type : `maximum value of the event type to be considered;
                    SDL_EVENT_LAST is a safe choice.`
 @return `the number of events actually stored or -1 on failure; call
          SDL_GetError() for more information.`
*>
extern fn CInt peep_events(SDLEvent*  events, int num_events, SDLEventAction action, uint min_type, uint max_type) @extern("SDL_PeepEvents");

<*
 Check for the existence of a certain event type in the event queue.
 This function is available since SDL 3.2.0.

 If you need to check for a range of event types, use SDL_HasEvents()
 instead.

 threadsafety: It is safe to call this function from any thread.

 @param type : `the type of event to be queried; see SDL_EventType for details.`
 @return `true if events matching 'type' are present, or false if events
          matching 'type' are not present.`
*>
extern fn bool has_event(uint type) @extern("SDL_HasEvent");

<*
 Check for the existence of certain event types in the event queue.
 This function is available since SDL 3.2.0.

 If you need to check for a single event type, use SDL_HasEvent() instead.

 threadsafety: It is safe to call this function from any thread.

 @param min_type : `the low end of event type to be queried, inclusive; see
                    SDL_EventType for details.`
 @param max_type : `the high end of event type to be queried, inclusive; see
                    SDL_EventType for details.`
 @return `true if events with type >= 'min_type' and <= 'max_type' are
          present, or false if not.`
*>
extern fn bool has_events(uint min_type, uint max_type) @extern("SDL_HasEvent");

<*
 Clear events of a specific type from the event queue.
 This function is available since SDL 3.2.0.

 This will unconditionally remove any events from the queue that match
 `type`. If you need to remove a range of event types, use SDL_FlushEvents()
 instead.

 It's also normal to just ignore events you don't care about in your event
 loop without calling this function.

 This function only affects currently queued events. If you want to make
 sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 on the main thread immediately before the flush call.

 If you have user events with custom data that needs to be freed, you should
 use SDL_PeepEvents() to remove and clean up those events before calling
 this function.

 threadsafety: It is safe to call this function from any thread.

 @param type : `the type of event to be cleared; see SDL_EventType for details.`
*>
extern fn void flush_event(uint type) @extern("SDL_FlushEvent");

<*
 Clear events of a range of types from the event queue.
 This function is available since SDL 3.2.0.

 This will unconditionally remove any events from the queue that are in the
 range of `minType` to `maxType`, inclusive. If you need to remove a single
 event type, use SDL_FlushEvent() instead.

 It's also normal to just ignore events you don't care about in your event
 loop without calling this function.

 This function only affects currently queued events. If you want to make
 sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 on the main thread immediately before the flush call.

 threadsafety: It is safe to call this function from any thread.

 @param min_type : `the low end of event type to be cleared, inclusive; see
                    SDL_EventType for details.`
 @param max_type : `the high end of event type to be cleared, inclusive; see
                    SDL_EventType for details.`
*>
extern fn void flush_events(uint min_type, uint max_type) @extern("SDL_FlushEvents");

<*
 Poll for currently pending events.
 This function is available since SDL 3.2.0.

 If `event` is not NULL, the next event is removed from the queue and stored
 in the SDL_Event structure pointed to by `event`. The 1 returned refers to
 this event, immediately stored in the SDL Event structure -- not an event
 to follow.

 If `event` is NULL, it simply returns 1 if there is an event in the queue,
 but will not remove it from the queue.

 As this function may implicitly call SDL_PumpEvents(), you can only call
 this function in the thread that set the video mode.

 SDL_PollEvent() is the favored way of receiving system events since it can
 be done from the main loop and does not suspend the main loop while waiting
 on an event to be posted.

 The common practice is to fully process the event queue once every frame,
 usually as a first step before updating the game's state:

 ```c
 while (game_is_still_running) {
     SDL_Event event;
     while (SDL_PollEvent(&event)) {  // poll until all events are handled!
         // decide what to do with this event.
     }

     // update game state, draw the current frame
 }
 ```
 threadsafety: This function should only be called on the main thread.

 @param event : `the SDL_Event structure to be filled with the next event from
                 the queue, or NULL.`
 @return `true if this got an event or false if there are none available.`
*>
extern fn bool poll_event(SDLEvent* event) @extern("SDL_PollEvent");

<*
 Wait indefinitely for the next available event.
 This function is available since SDL 3.2.0.

 If `event` is not NULL, the next event is removed from the queue and stored
 in the SDL_Event structure pointed to by `event`.

 As this function may implicitly call SDL_PumpEvents(), you can only call
 this function in the thread that initialized the video subsystem.

 threadsafety: This function should only be called on the main thread.

 @param event : `the SDL_Event structure to be filled in with the next event
                 from the queue, or NULL.`
 @return `true on success or false if there was an error while waiting for
          events; call SDL_GetError() for more information.`
*>
extern fn bool wait_event(SDLEvent* event) @extern("SDL_WaitEvent");

<*
 Wait until the specified timeout (in milliseconds) for the next available
 event.
 This function is available since SDL 3.2.0.

 If `event` is not NULL, the next event is removed from the queue and stored
 in the SDL_Event structure pointed to by `event`.

 As this function may implicitly call SDL_PumpEvents(), you can only call
 this function in the thread that initialized the video subsystem.

 The timeout is not guaranteed, the actual wait time could be longer due to
 system scheduling.

 threadsafety: This function should only be called on the main thread.

 @param event : `the SDL_Event structure to be filled in with the next event
                 from the queue, or NULL.`
 @param timeout_ms : `the maximum number of milliseconds to wait for the next
                      available event.`
 @return `true if this got an event or false if the timeout elapsed without
          any events available.`
*>
extern fn bool wait_event_timeout(SDLEvent* event, int timeout_ms) @extern("SDL_WaitEventTimeout");

<*
 Add an event to the event queue.
 This function is available since SDL 3.2.0.

 The event queue can actually be used as a two way communication channel.
 Not only can events be read from the queue, but the user can also push
 their own events onto it. `event` is a pointer to the event structure you
 wish to push onto the queue. The event is copied into the queue, and the
 caller may dispose of the memory pointed to after SDL_PushEvent() returns.

 Note: Pushing device input events onto the queue doesn't modify the state
 of the device within SDL.

 Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 the event filter but events added with SDL_PeepEvents() do not.

 For pushing application-specific events, please use SDL_RegisterEvents() to
 get an event type that does not conflict with other code that also wants
 its own custom event types.

 threadsafety: It is safe to call this function from any thread.

 @param event : `the SDL_Event to be added to the queue.`
 @return `true on success, false if the event was filtered or on failure;
          call SDL_GetError() for more information. A common reason for
          error is the event queue being full. `
*>
extern fn bool push_event(SDLEvent *event) @extern("SDL_PushEvent");

/*
 A function pointer used for callbacks that watch the event queue.
 This datatype is available since SDL 3.2.0.

 threadsafety: SDL may call this callback at any time from any thread; the
               application is responsible for locking resources the callback
               touches that need to be protected.

 @param userdata : `what was passed as 'userdata' to SDL_SetEventFilter() or
                    SDL_AddEventWatch, etc.`
 @param event : `the event that triggered the callback.`
 @return `true to permit event to be added to the queue, and false to
          disallow it. When used with SDL_AddEventWatch, the return value is
          ignored.`
*/
alias SDLEventFilter = fn bool(void* userdata, SDLEvent* event);

<*
 Set up a filter to process all events before they are added to the internal
 event queue.
 This function is available since SDL 3.2.0.

 If you just want to see events without modifying them or preventing them
 from being queued, you should use SDL_AddEventWatch() instead.

 If the filter function returns true when called, then the event will be
 added to the internal queue. If it returns false, then the event will be
 dropped from the queue, but the internal state will still be updated. This
 allows selective filtering of dynamically arriving events.

 **WARNING**: Be very careful of what you do in the event filter function,
 as it may run in a different thread!

 On platforms that support it, if the quit event is generated by an
 interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
 application at the next event poll.

 Note: Disabled events never make it to the event filter function; see
 SDL_SetEventEnabled().

 Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 the event filter, but events pushed onto the queue with SDL_PeepEvents() do
 not.

 threadsafety: It is safe to call this function from any thread.

 @param filter : `an SDL_EventFilter function to call when an event happens.`
 @param userdata : `a pointer that is passed to 'filter'.`
*>
extern fn void set_event_filter(SDLEventFilter filter, void* userdata) @extern("SDL_SetEventFilter");

<*
 Query the current event filter.
 This function is available since SDL 3.2.0.

 This function can be used to "chain" filters, by saving the existing filter
 before replacing it with a function that will call that saved filter.

 threadsafety: It is safe to call this function from any thread.

 @param filter : `the current callback function will be stored here.`
 @param userdata : `the pointer that is passed to the current event filter will
                    be stored here.`
 @return `true on success or false if there is no event filter set.`
*>
extern fn bool get_event_filter(SDLEventFilter* filter, void** userdata) @extern("SDL_GetEventFilter");

<*
 Add a callback to be triggered when an event is added to the event queue.
 This function is available since SDL 3.2.0.

 `filter` will be called when an event happens, and its return value is
 ignored.

 **WARNING**: Be very careful of what you do in the event filter function,
 as it may run in a different thread!

 If the quit event is generated by a signal (e.g. SIGINT), it will bypass
 the internal queue and be delivered to the watch callback immediately, and
 arrive at the next event poll.

 Note: the callback is called for events posted by the user through
 SDL_PushEvent(), but not for disabled events, nor for events by a filter
 callback set with SDL_SetEventFilter(), nor for events posted by the user
 through SDL_PeepEvents().

 threadsafety: It is safe to call this function from any thread.

 @param filter : `an SDL_EventFilter function to call when an event happens.`
 @param userdata : `a pointer that is passed to 'filter'.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool add_event_watch(SDLEventFilter filter, void* userdata) @extern("SDL_AddEventWatch");

<*
 Remove an event watch callback added with SDL_AddEventWatch().
 This function is available since SDL 3.2.0.

 This function takes the same input as SDL_AddEventWatch() to identify and
 delete the corresponding callback.

 threadsafety : It is safe to call this function from any thread.

 @param filter : `the function originally passed to SDL_AddEventWatch().`
 @param userdata : `the pointer originally passed to SDL_AddEventWatch().`
*>
extern fn void remove_event_watch(SDLEventFilter filter, void* userdata) @extern("SDL_RemoveEventWatch");

<*
 Run a specific filter function on the current event queue, removing any
 events for which the filter returns false.
 This function is available since SDL 3.2.0.

 See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
 this function does not change the filter permanently, it only uses the
 supplied filter until this function returns.

 threadsafety: It is safe to call this function from any thread.

 @param filter : `the SDL_EventFilter function to call when an event happens.`
 @param userdata : `a pointer that is passed to 'filter'.`
*>
extern fn void filter_events(SDLEventFilter filter, void* userdata) @extern("SDL_FilterEvents");

<*
 Set the state of processing events by type.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param type : `the type of event; see SDL_EventType for details.`
 @param enabled : `whether to process the event or not.`
*>
extern fn void set_event_enabled(uint type, bool enabled) @extern("SDL_SetEventEnabled");

<*
 Query the state of processing events by type.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param type : `the type of event; see SDL_EventType for details.`
 @returns `true if the event is being processed, false otherwise.`
*>
extern fn bool event_enabled(uint type) @extern("SDL_EventEnabled");

<*
 Allocate a set of user-defined events, and return the beginning event
 number for that set of events.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param num_events : `the number of events to be allocated.`
 @return `the beginning event number, or 0 if numevents is invalid or if
          there are not enough user-defined events left.`
*>
extern fn uint register_events(int num_events) @extern("SDL_RegisterEvents");

<*
 Get window associated with an event.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param event : `an event containing a 'windowID'.`
 @return `the associated window on success or NULL if there is none.`
*>
extern fn SDLWindow* get_window_from_event(SDLEvent* event) @extern("SDL_GetWindowFromEvent");
