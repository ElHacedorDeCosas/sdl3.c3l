<*
 The SDL haptic subsystem manages haptic (force feedback) devices.

 The basic usage is as follows:

 - Initialize the subsystem (SDL_INIT_HAPTIC).
 - Open a haptic device.
 - SDL_OpenHaptic() to open from index.
 - SDL_OpenHapticFromJoystick() to open from an existing joystick.
 - Create an effect (SDL_HapticEffect).
 - Upload the effect with SDL_CreateHapticEffect().
 - Run the effect with SDL_RunHapticEffect().
 - (optional) Free the effect with SDL_DestroyHapticEffect().
 - Close the haptic device with SDL_CloseHaptic().

 Simple rumble example:

 ```c
	SDL_Haptic *haptic = NULL;

	// Open the device
	SDL_HapticID *haptics = SDL_GetHaptics(NULL);
	if (haptics) {
		haptic = SDL_OpenHaptic(haptics[0]);
		SDL_free(haptics);
	}
	if (haptic == NULL)
	   return;

	// Initialize simple rumble
	if (!SDL_InitHapticRumble(haptic))
	   return;

	// Play effect at 50% strength for 2 seconds
	if (!SDL_PlayHapticRumble(haptic, 0.5, 2000))
	   return;
	SDL_Delay(2000);

	// Clean up
	SDL_CloseHaptic(haptic);
 ```

 Complete example:

 ```c
 bool test_haptic(SDL_Joystick *joystick)
 {
	SDL_Haptic *haptic;
	SDL_HapticEffect effect;
	int effect_id;

	// Open the device
	haptic = SDL_OpenHapticFromJoystick(joystick);
	if (haptic == NULL) return false; // Most likely joystick isn't haptic

	// See if it can do sine waves
	if ((SDL_GetHapticFeatures(haptic) & SDL_HAPTIC_SINE)==0) {
	   SDL_CloseHaptic(haptic); // No sine effect
	   return false;
	}

	// Create the effect
	SDL_memset(&effect, 0, sizeof(SDL_HapticEffect)); // 0 is safe default
	effect.type = SDL_HAPTIC_SINE;
	effect.periodic.direction.type = SDL_HAPTIC_POLAR; // Polar coordinates
	effect.periodic.direction.dir[0] = 18000; // Force comes from south
	effect.periodic.period = 1000; // 1000 ms
	effect.periodic.magnitude = 20000; // 20000/32767 strength
	effect.periodic.length = 5000; // 5 seconds long
	effect.periodic.attack_length = 1000; // Takes 1 second to get max strength
	effect.periodic.fade_length = 1000; // Takes 1 second to fade away

	// Upload the effect
	effect_id = SDL_CreateHapticEffect(haptic, &effect);

	// Test the effect
	SDL_RunHapticEffect(haptic, effect_id, 1);
	SDL_Delay(5000); // Wait for the effect to finish

	// We destroy the effect, although closing the device also does this
	SDL_DestroyHapticEffect(haptic, effect_id);

	// Close the device
	SDL_CloseHaptic(haptic);

	return true; // Success
 }
 ```

 Note that the SDL haptic subsystem is not thread-safe.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryHaptic
*>
module sdl;
/* FIXME:

 At the moment the magnitude variables are mixed between signed/unsigned, and
 it is also not made clear that ALL of those variables expect a max of 0x7FFF.

 Some platforms may have higher precision than that (Linux FF, Windows XInput)
 so we should fix the inconsistency in favor of higher possible precision,
 adjusting for platforms that use different scales.
 -flibit
 */

<*
 The haptic structure used to identify an SDL haptic.
 This struct is available since SDL 3.2.0.
*>
typedef SDLHaptic = void;

/*
  Haptic features
  Different haptic features a device can have.
*/

/* Haptic effects */

<*
 Constant effect supported.
 This macro is available since SDL 3.2.0.

 Constant haptic effect.
*>
const HAPTIC_CONSTANT =     (1u<<0);

<*
 Sine wave effect supported.
 This macro is available since SDL 3.2.0.

 Periodic haptic effect that simulates sine waves.
*>
const HAPTIC_SINE =         (1u<<1);

<*
 Square wave effect supported.
 This macro is available since SDL 3.2.0.

 Periodic haptic effect that simulates square waves.
*>
const HAPTIC_SQUARE =       (1u<<2);

<*
 Triangle wave effect supported.
 This macro is available since SDL 3.2.0.

 Periodic haptic effect that simulates triangular waves.
*>
const HAPTIC_TRIANGLE =     (1u<<3);

<*
 Sawtoothup wave effect supported.
 This macro is available since SDL 3.2.0.

 Periodic haptic effect that simulates saw tooth up waves.
*>
const HAPTIC_SAWTOOTHUP =   (1u<<4);

<*
 Sawtoothdown wave effect supported.
 This macro is available since SDL 3.2.0.

 Periodic haptic effect that simulates saw tooth down waves.
*>
const HAPTIC_SAWTOOTHDOWN = (1u<<5);

<*
 Ramp effect supported.
 This macro is available since SDL 3.2.0.

 Ramp haptic effect.
*>
const HAPTIC_RAMP =         (1u<<6);

<*
 Spring effect supported - uses axes position.
 This macro is available since SDL 3.2.0.

 Condition haptic effect that simulates a spring. Effect is based on the
 axes position.
*>
const HAPTIC_SPRING =       (1u<<7);

<*
 Damper effect supported - uses axes velocity.
 This macro is available since SDL 3.2.0.

 Condition haptic effect that simulates dampening. Effect is based on the
 axes velocity.
*>
const HAPTIC_DAMPER =       (1u<<8);

<*
 Inertia effect supported - uses axes acceleration.
 This macro is available since SDL 3.2.0.

 Condition haptic effect that simulates inertia. Effect is based on the axes
 acceleration.
*>
const HAPTIC_INERTIA =      (1u<<9);

<*
 Friction effect supported - uses axes movement.
 This macro is available since SDL 3.2.0.

 Condition haptic effect that simulates friction. Effect is based on the
 axes movement.
*>
const HAPTIC_FRICTION =     (1u<<10);

<*
 Left/Right effect supported.
 This macro is available since SDL 3.2.0.

 Haptic effect for direct control over high/low frequency motors.
*>
const HAPTIC_LEFTRIGHT =    (1u<<11);

<*
 Reserved for future use.

 \since This macro is available since SDL 3.2.0.
*>
const HAPTIC_RESERVED1 =    (1u<<12);

<*
 Reserved for future use.

 \since This macro is available since SDL 3.2.0.
*>
const HAPTIC_RESERVED2 =    (1u<<13);

<*
 Reserved for future use.

 \since This macro is available since SDL 3.2.0.
*>
const HAPTIC_RESERVED3 =    (1u<<14);

<*
 Custom effect is supported.
 This macro is available since SDL 3.2.0.

 User defined custom haptic effect.
*>
const HAPTIC_CUSTOM =       (1u<<15);

/* @} *//* Haptic effects */

/* These last few are features the device has, not effects */

<*
 Device can set global gain.
 This macro is available since SDL 3.2.0.

 Device supports setting the global gain.
*>
const HAPTIC_GAIN =       (1u<<16);

<*
 Device can set autocenter.
 This macro is available since SDL 3.2.0.

 Device supports setting autocenter.
*>
const HAPTIC_AUTOCENTER = (1u<<17);

<*
 Device can be queried for effect status.
 This macro is available since SDL 3.2.0.

 Device supports querying effect status.
*>
const HAPTIC_STATUS =     (1u<<18);

<*
 Device can be paused.
 This macro is available since SDL 3.2.0.

 Devices supports being paused.
*>
const HAPTIC_PAUSE =      (1u<<19);


/* Direction encodings */

<*
 Uses polar coordinates for the direction.
 This macro is available since SDL 3.2.0.
*>
const HAPTIC_POLAR =      0;

<*
 Uses cartesian coordinates for the direction.
 This macro is available since SDL 3.2.0.
*>
const HAPTIC_CARTESIAN =  1;

<*
 Uses spherical coordinates for the direction.
 This macro is available since SDL 3.2.0.
*>
const HAPTIC_SPHERICAL =  2;

<*
 Use this value to play an effect on the steering wheel axis.
 This macro is available since SDL 3.2.0.

 This provides better compatibility across platforms and devices as SDL will
 guess the correct axis.
*>
const HAPTIC_STEERING_AXIS = 3;

/* @} *//* Direction encodings */

/* @} *//* Haptic features */

/* Misc defines. */

<*
 Used to play a device an infinite number of times.
 This macro is available since SDL 3.2.0.
*>
const HAPTIC_INFINITY =   4294967295U;


<*
 Structure that represents a haptic direction.
 This struct is available since SDL 3.2.0.

 This is the direction where the force comes from, instead of the direction
 in which the force is exerted.

 Directions can be specified by:

 - SDL_HAPTIC_POLAR : Specified by polar coordinates.
 - SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
 - SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.

 Cardinal directions of the haptic device are relative to the positioning of
 the device. North is considered to be away from the user.

 The following diagram represents the cardinal directions:

 ```
				.--.
				|__| .-------.
				|=.| |.-----.|
				|--| ||     ||
				|  | |'-----'|
				|__|~')_____('
				  [ COMPUTER ]


					North (0,-1)
						^
						|
						|
  (-1,0)  West <----[ HAPTIC ]----> East (1,0)
						|
						|
						v
					 South (0,1)


					 [ USER ]
					   \|||/
					   (o o)
				 ---ooO-(_)-Ooo---
 ```

 If type is SDL_HAPTIC_POLAR, direction is encoded by hundredths of a degree
 starting north and turning clockwise. SDL_HAPTIC_POLAR only uses the first
 `dir` parameter. The cardinal directions would be:

 - North: 0 (0 degrees)
 - East: 9000 (90 degrees)
 - South: 18000 (180 degrees)
 - West: 27000 (270 degrees)

 If type is SDL_HAPTIC_CARTESIAN, direction is encoded by three positions (X
 axis, Y axis and Z axis (with 3 axes)). SDL_HAPTIC_CARTESIAN uses the first
 three `dir` parameters. The cardinal directions would be:

 - North: 0,-1, 0
 - East: 1, 0, 0
 - South: 0, 1, 0
 - West: -1, 0, 0

 The Z axis represents the height of the effect if supported, otherwise it's
 unused. In cartesian encoding (1, 2) would be the same as (2, 4), you can
 use any multiple you want, only the direction matters.

 If type is SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations. The
 first two `dir` parameters are used. The `dir` parameters are as follows
 (all values are in hundredths of degrees):

 - Degrees from (1, 0) rotated towards (0, 1).
 - Degrees towards (0, 0, 1) (device needs at least 3 axes).

 Example of force coming from the south with all encodings (force coming
 from the south means the user will have to pull the stick to counteract):

 ```c
  SDL_HapticDirection direction;

  // Cartesian directions
  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
  direction.dir[0] = 0; // X position
  direction.dir[1] = 1; // Y position
  // Assuming the device has 2 axes, we don't need to specify third parameter.

  // Polar directions
  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
  direction.dir[0] = 18000; // Polar only uses first parameter

  // Spherical coordinates
  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
 ```
*>
struct SDLHapticDirection
{
	char type;         /**< The type of encoding. */
	int[3] dir;        /**< The encoded direction. */
}

<*
 A structure containing a template for a Constant effect.
 This struct is available since SDL 3.2.0.

 This struct is exclusively for the SDL_HAPTIC_CONSTANT effect.

 A constant effect applies a constant force in the specified direction to
 the joystick.
*>
struct SDLHapticConstant
{
	/* Header */
	ushort type;            /**< SDL_HAPTIC_CONSTANT */
	SDLHapticDirection direction;  /**< Direction of the effect. */

	/* Replay */
	uint length;            /**< Duration of the effect. */
	ushort delay;           /**< Delay before starting the effect. */

	/* Trigger */
	ushort button;          /**< Button that triggers the effect. */
	ushort interval;        /**< How soon it can be triggered again after button. */

	/* Constant */
	short level;            /**< Strength of the constant effect. */

	/* Envelope */
	ushort attack_length;   /**< Duration of the attack. */
	ushort attack_level;    /**< Level at the start of the attack. */
	ushort fade_length;     /**< Duration of the fade. */
	ushort fade_level;      /**< Level at the end of the fade. */
}

<*
 A structure containing a template for a Periodic effect.
 This struct is available since SDL 3.2.0.

 The struct handles the following effects:

 - SDL_HAPTIC_SINE
 - SDL_HAPTIC_SQUARE
 - SDL_HAPTIC_TRIANGLE
 - SDL_HAPTIC_SAWTOOTHUP
 - SDL_HAPTIC_SAWTOOTHDOWN

 A periodic effect consists in a wave-shaped effect that repeats itself over
 time. The type determines the shape of the wave and the parameters
 determine the dimensions of the wave.

 Phase is given by hundredth of a degree meaning that giving the phase a
 value of 9000 will displace it 25% of its period. Here are sample values:

 - 0: No phase displacement.
 - 9000: Displaced 25% of its period.
 - 18000: Displaced 50% of its period.
 - 27000: Displaced 75% of its period.
 - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.

 Examples:

 ```
   SDL_HAPTIC_SINE
	 __      __      __      __
	/  \    /  \    /  \    /
   /    \__/    \__/    \__/

   SDL_HAPTIC_SQUARE
	__    __    __    __    __
   |  |  |  |  |  |  |  |  |  |
   |  |__|  |__|  |__|  |__|  |

   SDL_HAPTIC_TRIANGLE
	 /\    /\    /\    /\    /\
	/  \  /  \  /  \  /  \  /
   /    \/    \/    \/    \/

   SDL_HAPTIC_SAWTOOTHUP
	 /|  /|  /|  /|  /|  /|  /|
	/ | / | / | / | / | / | / |
   /  |/  |/  |/  |/  |/  |/  |

   SDL_HAPTIC_SAWTOOTHDOWN
   \  |\  |\  |\  |\  |\  |\  |
	\ | \ | \ | \ | \ | \ | \ |
	 \|  \|  \|  \|  \|  \|  \|
 ```
*>
struct SDLHapticPeriodic
{
	/* Header */
	ushort type; 		/**< SDL_HAPTIC_SINE, SDL_HAPTIC_SQUARE
							SDL_HAPTIC_TRIANGLE, SDL_HAPTIC_SAWTOOTHUP or
							SDL_HAPTIC_SAWTOOTHDOWN */
	SDLHapticDirection direction;  /**< Direction of the effect. */

	/* Replay */
	uint length; 			/**< Duration of the effect. */
	ushort delay; 			/**< Delay before starting the effect. */

	/* Trigger */
	ushort button; 			/**< Button that triggers the effect. */
	ushort interval; 		/**< How soon it can be triggered again after button. */

	/* Periodic */
	ushort period; 			/**< Period of the wave. */
	short magnitude; 		/**< Peak value; if negative, equivalent to 180 degrees extra phase shift. */
	short offset; 			/**< Mean value of the wave. */
	ushort phase; 			/**< Positive phase shift given by hundredth of a degree. */

	/* Envelope */
	ushort attack_length; 	/**< Duration of the attack. */
	ushort attack_level; 	/**< Level at the start of the attack. */
	ushort fade_length; 	/**< Duration of the fade. */
	ushort fade_level; 		/**< Level at the end of the fade. */
}

<*
 A structure containing a template for a Condition effect.
 This struct is available since SDL 3.2.0.

 The struct handles the following effects:

 - SDL_HAPTIC_SPRING: Effect based on axes position.
 - SDL_HAPTIC_DAMPER: Effect based on axes velocity.
 - SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
 - SDL_HAPTIC_FRICTION: Effect based on axes movement.

 Direction is handled by condition internals instead of a direction member.
 The condition effect specific members have three parameters. The first
 refers to the X axis, the second refers to the Y axis and the third refers
 to the Z axis. The right terms refer to the positive side of the axis and
 the left terms refer to the negative side of the axis. Please refer to the
 SDL_HapticDirection diagram for which side is positive and which is
 negative.
*>
struct SDLHapticCondition
{
	/* Header */
	ushort type;            /**< SDL_HAPTIC_SPRING, SDL_HAPTIC_DAMPER,
								SDL_HAPTIC_INERTIA or SDL_HAPTIC_FRICTION */
	SDLHapticDirection direction;  /**< Direction of the effect. */

	/* Replay */
	uint length;            /**< Duration of the effect. */
	ushort delay;           /**< Delay before starting the effect. */

	/* Trigger */
	ushort button;          /**< Button that triggers the effect. */
	ushort interval;        /**< How soon it can be triggered again after button. */

	/* Condition */
	ushort[3] right_sat;    /**< Level when joystick is to the positive side; max 0xFFFF. */
	ushort[3] left_sat;     /**< Level when joystick is to the negative side; max 0xFFFF. */
	short[3] right_coeff;   /**< How fast to increase the force towards the positive side. */
	short[3] left_coeff;    /**< How fast to increase the force towards the negative side. */
	ushort[3] deadband;     /**< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered. */
	short[3] center;        /**< Position of the dead zone. */
}

<*
 A structure containing a template for a Ramp effect.
 This struct is available since SDL 3.2.0.

 This struct is exclusively for the SDL_HAPTIC_RAMP effect.

 The ramp effect starts at start strength and ends at end strength. It
 augments in linear fashion. If you use attack and fade with a ramp the
 effects get added to the ramp effect making the effect become quadratic
 instead of linear.
*>
struct SDLHapticRamp
{
	/* Header */
	ushort type;            /**< SDL_HAPTIC_RAMP */
	SDLHapticDirection direction;  /**< Direction of the effect. */

	/* Replay */
	uint length;            /**< Duration of the effect. */
	ushort delay;           /**< Delay before starting the effect. */

	/* Trigger */
	ushort button;          /**< Button that triggers the effect. */
	ushort interval;        /**< How soon it can be triggered again after button. */

	/* Ramp */
	short start;            /**< Beginning strength level. */
	short end;              /**< Ending strength level. */

	/* Envelope */
	ushort attack_length;   /**< Duration of the attack. */
	ushort attack_level;    /**< Level at the start of the attack. */
	ushort fade_length;     /**< Duration of the fade. */
	ushort fade_level;      /**< Level at the end of the fade. */
}

<*
 A structure containing a template for a Left/Right effect.
 This struct is available since SDL 3.2.0.

 This struct is exclusively for the SDL_HAPTIC_LEFTRIGHT effect.

 The Left/Right effect is used to explicitly control the large and small
 motors, commonly found in modern game controllers. The small (right) motor
 is high frequency, and the large (left) motor is low frequency.
*>
struct SDLHapticLeftRight
{
	/* Header */
	ushort type;            /**< SDL_HAPTIC_LEFTRIGHT */

	/* Replay */
	uint length;            /**< Duration of the effect in milliseconds. */

	/* Rumble */
	ushort large_magnitude; /**< Control of the large controller motor. */
	ushort small_magnitude; /**< Control of the small controller motor. */
}

<*
 A structure containing a template for the SDL_HAPTIC_CUSTOM effect.
 This struct is available since SDL 3.2.0.

 This struct is exclusively for the SDL_HAPTIC_CUSTOM effect.

 A custom force feedback effect is much like a periodic effect, where the
 application can define its exact shape. You will have to allocate the data
 yourself. Data should consist of channels * samples Uint16 samples.

 If channels is one, the effect is rotated using the defined direction.
 Otherwise it uses the samples in data for the different axes.
*>
struct SDLHapticCustom
{
	/* Header */
	ushort type;            /**< SDL_HAPTIC_CUSTOM */
	SDLHapticDirection direction;  /**< Direction of the effect. */

	/* Replay */
	uint length;          /**< Duration of the effect. */
	ushort delay;           /**< Delay before starting the effect. */

	/* Trigger */
	ushort button;          /**< Button that triggers the effect. */
	ushort interval;        /**< How soon it can be triggered again after button. */

	/* Custom */
	char channels;         /**< Axes to use, minimum of one. */
	ushort period;          /**< Sample periods. */
	ushort samples;         /**< Amount of samples. */
	ushort *data;           /**< Should contain channels*samples items. */

	/* Envelope */
	ushort attack_length;   /**< Duration of the attack. */
	ushort attack_level;    /**< Level at the start of the attack. */
	ushort fade_length;     /**< Duration of the fade. */
	ushort fade_level;      /**< Level at the end of the fade. */
}

<*
 The generic template for any haptic effect.
 This struct is available since SDL 3.2.0.

 All values max at 32767 (0x7FFF). Signed values also can be negative. Time
 values unless specified otherwise are in milliseconds.

 You can also pass SDL_HAPTIC_INFINITY to length instead of a 0-32767 value.
 Neither delay, interval, attack_length nor fade_length support
 SDL_HAPTIC_INFINITY. Fade will also not be used since effect never ends.

 Additionally, the SDL_HAPTIC_RAMP effect does not support a duration of
 SDL_HAPTIC_INFINITY.

 Button triggers may not be supported on all devices, it is advised to not
 use them if possible. Buttons start at index 1 instead of index 0 like the
 joystick.

 If both attack_length and fade_level are 0, the envelope is not used,
 otherwise both values are used.

 Common parts:

 ```c
  // Replay - All effects have this
  Uint32 length;        // Duration of effect (ms).
  Uint16 delay;         // Delay before starting effect.

  // Trigger - All effects have this
  Uint16 button;        // Button that triggers effect.
  Uint16 interval;      // How soon before effect can be triggered again.

  // Envelope - All effects except condition effects have this
  Uint16 attack_length; // Duration of the attack (ms).
  Uint16 attack_level;  // Level at the start of the attack.
  Uint16 fade_length;   // Duration of the fade out (ms).
  Uint16 fade_level;    // Level at the end of the fade.
 ```

 Here we have an example of a constant effect evolution in time:

 ```
  Strength
  ^
  |
  |    effect level -->  _________________
  |                     /                 \
  |                    /                   \
  |                   /                     \
  |                  /                       \
  | attack_level --> |                        \
  |                  |                        |  <---  fade_level
  |
  +--------------------------------------------------> Time
					 [--]                 [---]
					 attack_length        fade_length

  [------------------][-----------------------]
  delay               length
 ```

 Note either the attack_level or the fade_level may be above the actual
 effect level.
*>
union SDLHapticEffect
{
	/* Common for all force feedback effects */
	ushort type;                   /**< Effect type. */
	SDLHapticConstant constant;    /**< Constant effect. */
	SDLHapticPeriodic periodic;    /**< Periodic effect. */
	SDLHapticCondition condition;  /**< Condition effect. */
	SDLHapticRamp ramp;            /**< Ramp effect. */
	SDLHapticLeftRight leftright;  /**< Left/Right effect. */
	SDLHapticCustom custom;        /**< Custom effect. */
}

<*
 This is a unique ID for a haptic device for the time it is connected to the
 system, and is never reused for the lifetime of the application.
 This datatype is available since SDL 3.2.0.

 If the haptic device is disconnected and reconnected, it will get a new ID.

 The value 0 is an invalid ID.
*>
typedef SDLHapticID = uint;

/* Function prototypes */

<*
 Get a list of currently connected haptic devices.
 This function is available since SDL 3.2.0.

 @param count : `a pointer filled in with the number of haptic devices
			  returned, may be NULL.`
 @return `a 0 terminated array of haptic device instance IDs or NULL on
		  failure; call SDL_GetError() for more information. This should be
		  freed with SDL_free() when it is no longer needed.`
*>
extern fn SDLHapticID* get_haptics(CInt* count) @extern("SDL_GetHaptics");

<*
 Get the implementation dependent name of a haptic device.
 This function is available since SDL 3.2.0.

 This can be called before any haptic devices are opened.

 @param instance_id : `the haptic device instance ID.`
 @return `the name of the selected haptic device. If no name can be found,
		  this function returns NULL; call SDL_GetError() for more
		  information.`
*>
extern fn ZString SDLHapticID.get_haptic_name(instance_id) @extern("SDL_GetHapticNameForID");

<*
 Open a haptic device for use.
 This function is available since SDL 3.2.0.

 The index passed as an argument refers to the N'th haptic device on this
 system.

 When opening a haptic device, its gain will be set to maximum and
 autocenter will be disabled. To modify these values use SDL_SetHapticGain()
 and SDL_SetHapticAutocenter().

 @param instance_id : `the haptic device instance ID.`
 @return `the device identifier or NULL on failure; call SDL_GetError() for
		  more information.`
*>
extern fn SDLHaptic* SDLHapticID.open_haptic(instance_id) @extern("SDL_OpenHaptic");

<*
 Get the SDL_Haptic associated with an instance ID, if it has been opened.
 This function is available since SDL 3.2.0.

 @param instance_id : `the instance ID to get the SDL_Haptic for.`
 @return `an SDL_Haptic on success or NULL on failure or if it hasn't been
		  opened yet; call SDL_GetError() for more information.`
*>
extern fn SDLHaptic* SDLHapticID.get_haptic(SDLHapticID instance_id) @extern("SDL_GetHapticFromID");

<*
 Get the instance ID of an opened haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic device to query.`
 @return `the instance ID of the specified haptic device on success or 0 on
		  failure; call SDL_GetError() for more information.`
*>
extern fn SDLHapticID SDLHaptic.get_id(&haptic) @extern("SDL_GetHapticID");

<*
 Get the implementation dependent name of a haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic obtained from SDL_OpenJoystick().`
 @return `the name of the selected haptic device. If no name can be found,
		  this function returns NULL; call SDL_GetError() for more
		  information.`
*>
extern fn ZString SDLHaptic.get_name(&haptic) @extern("SDL_GetHapticName");

<*
 Query whether or not the current mouse has haptic capabilities.
 This function is available since SDL 3.2.0.

 @return `true if the mouse is haptic or false if it isn't.`
*>
extern fn bool is_mouse_haptic() @extern("SDL_IsMouseHaptic");

<*
 Try to open a haptic device from the current mouse.
 This function is available since SDL 3.2.0.

 @return `the haptic device identifier or NULL on failure; call
		  SDL_GetError() for more information.`
*>
extern fn SDLHaptic* open_haptic_from_mouse() @extern("SDL_OpenHapticFromMouse");

<*
 Query if a joystick has haptic features.
 This function is available since SDL 3.2.0.

 @param joystick : `the SDL_Joystick to test for haptic capabilities.`
 @return `true if the joystick is haptic or false if it isn't.`
*>
extern fn bool SDLJoystick.is_haptic(&joystick) @extern("SDL_IsJoystickHaptic");

<*
 Open a haptic device for use from a joystick device.
 This function is available since SDL 3.2.0.

 You must still close the haptic device separately. It will not be closed
 with the joystick.

 When opened from a joystick you should first close the haptic device before
 closing the joystick device. If not, on some implementations the haptic
 device will also get unallocated and you'll be unable to use force feedback
 on that device.

 @param joystick : `the SDL_Joystick to create a haptic device from.`
 @return `a valid haptic device identifier on success or NULL on failure;
		  call SDL_GetError() for more information.`
*>
extern fn SDLHaptic* SDLJoystick.open_haptic(&joystick) @extern("SDL_OpenHapticFromJoystick");

<*
 Close a haptic device previously opened with SDL_OpenHaptic().
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic device to close.`
*>
extern fn void SDLHaptic.close(&haptic) @extern("SDL_CloseHaptic");

<*
 Get the number of effects a haptic device can store.
 This function is available since SDL 3.2.0.

 On some platforms this isn't fully supported, and therefore is an
 approximation. Always check to see if your created effect was actually
 created and do not rely solely on SDL_GetMaxHapticEffects().

 @param haptic : `the SDL_Haptic device to query.`
 @return `the number of effects the haptic device can store or a negative
		  error code on failure; call SDL_GetError() for more information.`
*>
extern fn CInt SDLHaptic.get_max_effects(&haptic) @extern("SDL_GetMaxHapticEffects");

<*
 Get the number of effects a haptic device can play at the same time.
 This function is available since SDL 3.2.0.

 This is not supported on all platforms, but will always return a value.

 @param haptic : `the SDL_Haptic device to query maximum playing effects.`
 @return `the number of effects the haptic device can play at the same time
		  or -1 on failure; call SDL_GetError() for more information.`
*>
extern fn CInt SDLHaptic.get_max_effects_playing(&haptic) @extern("SDL_GetMaxHapticEffectsPlaying");

<*
 Get the haptic device's supported features in bitwise manner.
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic device to query.`
 @return `a list of supported haptic features in bitwise manner (OR'd), or 0
		  on failure; call SDL_GetError() for more information.`
*>
extern fn uint SDLHaptic.get_features(&haptic) @extern("SDL_GetHapticFeatures");

<*
 Get the number of haptic axes the device has.
 This function is available since SDL 3.2.0.

 The number of haptic axes might be useful if working with the
 SDL_HapticDirection effect.

 @param haptic : `the SDL_Haptic device to query.`
 @return `the number of axes on success or -1 on failure; call
		  SDL_GetError() for more information.`
*>
extern fn CInt SDLHaptic.get_num_axes(&haptic) @extern("SDL_GetNumHapticAxes");

<*
 Check to see if an effect is supported by a haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic device to query.`
 @param effect : `the desired effect to query.`
 @return `true if the effect is supported or false if it isn't.`
*>
extern fn bool SDLHaptic.effect_supported(&haptic, SDLHapticEffect* effect) @extern("SDL_HapticEffectSupported");

<*
 Create a new haptic effect on a specified device.
 This function is available since SDL 3.2.0.

 @param haptic : `an SDL_Haptic device to create the effect on.`
 @param effect : `an SDL_HapticEffect structure containing the properties of
			   the effect to create.`
 @return `the ID of the effect on success or -1 on failure; call
		  SDL_GetError() for more information.`
*>
extern fn CInt SDLHaptic.create_effect(&haptic, SDLHapticEffect* effect) @extern("SDL_CreateHapticEffect");

<*
 Update the properties of an effect.
 This function is available since SDL 3.2.0.

 Can be used dynamically, although behavior when dynamically changing
 direction may be strange. Specifically the effect may re-upload itself and
 start playing from the start. You also cannot change the type either when
 running SDL_UpdateHapticEffect().

 @param haptic : `the SDL_Haptic device that has the effect.`
 @param effect : `the identifier of the effect to update.`
 @param data : `an SDL_HapticEffect structure containing the new effect
			 properties to use.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.update_effect(&haptic, CInt effect, SDLHapticEffect* data) @extern("SDL_UpdateHapticEffect");

<*
 Run the haptic effect on its associated haptic device.
 This function is available since SDL 3.2.0.

 To repeat the effect over and over indefinitely, set `iterations` to
 `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
 one instance of the effect last indefinitely (so the effect does not fade),
 set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
 instead.

 @param haptic : `the SDL_Haptic device to run the effect on.`
 @param effect : `the ID of the haptic effect to run.`
 @param iterations : `the number of iterations to run the effect; use
				   'SDL_HAPTIC_INFINITY' to repeat forever.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.run_effect(&haptic, CInt effect, uint iterations) @extern("SDL_RunHapticEffect");

<*
 Stop the haptic effect on its associated haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic device to stop the effect on.`
 @param effect : `the ID of the haptic effect to stop.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.stop_effect(&haptic, CInt effect) @extern("SDL_StopHapticEffect");

<*
 Destroy a haptic effect on the device.
 This function is available since SDL 3.2.0.

 This will stop the effect if it's running. Effects are automatically
 destroyed when the device is closed.

 @param haptic : `the SDL_Haptic device to destroy the effect on.`
 @param effect : `the ID of the haptic effect to destroy.`
*>
extern fn void SDLHaptic.destroy_effect(&haptic, CInt effect) @extern("SDL_DestroyHapticEffect");

<*
 Get the status of the current effect on the specified haptic device.
 This function is available since SDL 3.2.0.

 Device must support the SDL_HAPTIC_STATUS feature.

 @param haptic : `the SDL_Haptic device to query for the effect status on.`
 @param effect : `the ID of the haptic effect to query its status.`
 @return `true if it is playing, false if it isn't playing or haptic status
		  isn't supported.`
*>
extern fn bool SDLHaptic.get_effect_status(&haptic, CInt effect) @extern("SDL_GetHapticEffectStatus");

<*
 Set the global gain of the specified haptic device.
 This function is available since SDL 3.2.0.

 Device must support the SDL_HAPTIC_GAIN feature.

 The user may specify the maximum gain by setting the environment variable
 `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
 SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
 maximum.

 @param haptic : `the SDL_Haptic device to set the gain on.`
 @param gain : `value to set the gain to, should be between 0 and 100 (0 -
			 100).`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.set_gain(&haptic, CInt gain) @extern("SDL_SetHapticGain");

<*
 Set the global autocenter of the device.
 This function is available since SDL 3.2.0.

 Autocenter should be between 0 and 100. Setting it to 0 will disable
 autocentering.

 Device must support the SDL_HAPTIC_AUTOCENTER feature.

 @param haptic : `the SDL_Haptic device to set autocentering on.`
 @param autocenter : `value to set autocenter to (0-100).`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.set_autocenter(&haptic, CInt autocenter) @extern("SDL_SetHapticAutocenter");

<*
 Pause a haptic device.
 This function is available since SDL 3.2.0.

 Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()
 to resume playback.

 Do not modify the effects nor add new ones while the device is paused. That
 can cause all sorts of weird errors.

 @param haptic : `the SDL_Haptic device to pause.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.pause(&haptic) @extern("SDL_PauseHaptic");

<*
 Resume a haptic device.
 This function is available since SDL 3.2.0.

 Call to unpause after SDL_PauseHaptic().

 @param haptic : `the SDL_Haptic device to unpause.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.resume(&haptic) @extern("SDL_ResumeHaptic");

<*
 Stop all the currently playing effects on a haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the SDL_Haptic device to stop.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.stop_effects(&haptic) @extern("SDL_StopHapticEffects");

<*
 Check whether rumble is supported on a haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `haptic device to check for rumble support.`
 @return `true if the effect is supported or false if it isn't.`
*>
extern fn bool SDLHaptic.rumble_supported(&haptic) @extern("SDL_HapticRumbleSupported");

<*
 Initialize a haptic device for simple rumble playback.
 This function is available since SDL 3.2.0.

 @param haptic : `the haptic device to initialize for simple rumble playback.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.init_rumble(&haptic) @extern("SDL_InitHapticRumble");

<*
 Run a simple rumble effect on a haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the haptic device to play the rumble effect on.`
 @param strength : `strength of the rumble to play as a 0-1 float value.`
 @param length : `length of the rumble to play in milliseconds.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.play_rumble(&haptic, float strength, uint length) @extern("SDL_PlayHapticRumble");

<*
 Stop the simple rumble on a haptic device.
 This function is available since SDL 3.2.0.

 @param haptic : `the haptic device to stop the rumble effect on.`
 @return `true on success or false on failure; call SDL_GetError() for more
		  information.`
*>
extern fn bool SDLHaptic.stop_rumble(&haptic) @extern("SDL_StopHapticRumble");
