<*
 The storage API is a high-level API designed to abstract away the
 portability issues that come up when using something lower-level (in SDL's
 case, this sits on top of the [Filesystem](CategoryFilesystem) and
 [IOStream](CategoryIOStream) subsystems). It is significantly more
 restrictive than a typical filesystem API, for a number of reasons:

 1. **What to Access:** A common pitfall with existing filesystem APIs is
 the assumption that all storage is monolithic. However, many other
 platforms (game consoles in particular) are more strict about what _type_
 of filesystem is being accessed; for example, game content and user data
 are usually two separate storage devices with entirely different
 characteristics (and possibly different low-level APIs altogether!).

 2. **How to Access:** Another common mistake is applications assuming that
 all storage is universally writeable - again, many platforms treat game
 content and user data as two separate storage devices, and only user data
 is writeable while game content is read-only.

 3. **When to Access:** The most common portability issue with filesystem
 access is _timing_ - you cannot always assume that the storage device is
 always accessible all of the time, nor can you assume that there are no
 limits to how long you have access to a particular device.

 Consider the following example:

 ```c
 void ReadGameData(void)
 {
     extern char** fileNames;
     extern size_t numFiles;
     for (size_t i = 0; i < numFiles; i += 1) {
         FILE *data = fopen(fileNames[i], "rwb");
         if (data == NULL) {
             // Something bad happened!
         } else {
             // A bunch of stuff happens here
             fclose(data);
         }
     }
 }

 void ReadSave(void)
 {
     FILE *save = fopen("saves/save0.sav", "rb");
     if (save == NULL) {
         // Something bad happened!
     } else {
         // A bunch of stuff happens here
         fclose(save);
     }
 }

 void WriteSave(void)
 {
     FILE *save = fopen("saves/save0.sav", "wb");
     if (save == NULL) {
         // Something bad happened!
     } else {
         // A bunch of stuff happens here
         fclose(save);
     }
 }
 ```

 Going over the bullet points again:

 1. **What to Access:** This code accesses a global filesystem; game data
 and saves are all presumed to be in the current working directory (which
 may or may not be the game's installation folder!).

 2. **How to Access:** This code assumes that content paths are writeable,
 and that save data is also writeable despite being in the same location as
 the game data.

 3. **When to Access:** This code assumes that they can be called at any
 time, since the filesystem is always accessible and has no limits on how
 long the filesystem is being accessed.

 Due to these assumptions, the filesystem code is not portable and will fail
 under these common scenarios:

 - The game is installed on a device that is read-only, both content loading
   and game saves will fail or crash outright
 - Game/User storage is not implicitly mounted, so no files will be found
   for either scenario when a platform requires explicitly mounting
   filesystems
 - Save data may not be safe since the I/O is not being flushed or
   validated, so an error occurring elsewhere in the program may result in
   missing/corrupted save data

 When using SDL_Storage, these types of problems are virtually impossible to
 trip over:

 ```c
 void ReadGameData(void)
 {
     extern char** fileNames;
     extern size_t numFiles;

     SDL_Storage *title = SDL_OpenTitleStorage(NULL, 0);
     if (title == NULL) {
         // Something bad happened!
     }
     while (!SDL_StorageReady(title)) {
         SDL_Delay(1);
     }

     for (size_t i = 0; i < numFiles; i += 1) {
         void* dst;
         Uint64 dstLen = 0;

         if (SDL_GetStorageFileSize(title, fileNames[i], &dstLen) && dstLen > 0) {
             dst = SDL_malloc(dstLen);
             if (SDL_ReadStorageFile(title, fileNames[i], dst, dstLen)) {
                 // A bunch of stuff happens here
             } else {
                 // Something bad happened!
             }
             SDL_free(dst);
         } else {
             // Something bad happened!
         }
     }

     SDL_CloseStorage(title);
 }

 void ReadSave(void)
 {
     SDL_Storage *user = SDL_OpenUserStorage("libsdl", "Storage Example", 0);
     if (user == NULL) {
         // Something bad happened!
     }
     while (!SDL_StorageReady(user)) {
         SDL_Delay(1);
     }

     Uint64 saveLen = 0;
     if (SDL_GetStorageFileSize(user, "save0.sav", &saveLen) && saveLen > 0) {
         void* dst = SDL_malloc(saveLen);
         if (SDL_ReadStorageFile(user, "save0.sav", dst, saveLen)) {
             // A bunch of stuff happens here
         } else {
             // Something bad happened!
         }
         SDL_free(dst);
     } else {
         // Something bad happened!
     }

     SDL_CloseStorage(user);
 }

 void WriteSave(void)
 {
     SDL_Storage *user = SDL_OpenUserStorage("libsdl", "Storage Example", 0);
     if (user == NULL) {
         // Something bad happened!
     }
     while (!SDL_StorageReady(user)) {
         SDL_Delay(1);
     }

     extern void *saveData; // A bunch of stuff happened here...
     extern Uint64 saveLen;
     if (!SDL_WriteStorageFile(user, "save0.sav", saveData, saveLen)) {
         // Something bad happened!
     }

     SDL_CloseStorage(user);
 }
 ```

 Note the improvements that SDL_Storage makes:

 1. **What to Access:** This code explicitly reads from a title or user
 storage device based on the context of the function.

 2. **How to Access:** This code explicitly uses either a read or write
 function based on the context of the function.

 3. **When to Access:** This code explicitly opens the device when it needs
 to, and closes it when it is finished working with the filesystem.

 The result is an application that is significantly more robust against the
 increasing demands of platforms and their filesystems!

 A publicly available example of an SDL_Storage backend is the
 [Steam Cloud](https://partner.steamgames.com/doc/features/cloud)
 backend - you can initialize Steamworks when starting the program, and then
 SDL will recognize that Steamworks is initialized and automatically use
 ISteamRemoteStorage when the application opens user storage. More
 importantly, when you _open_ storage it knows to begin a "batch" of
 filesystem operations, and when you _close_ storage it knows to end and
 flush the batch. This is used by Steam to support
 [Dynamic Cloud Sync](https://steamcommunity.com/groups/steamworks/announcements/detail/3142949576401813670)
 ; users can save data on one PC, put the device to sleep, and then continue
 playing on another PC (and vice versa) with the save data fully
 synchronized across all devices, allowing for a seamless experience without
 having to do full restarts of the program.

 ## Notes on valid paths

 All paths in the Storage API use Unix-style path separators ('/'). Using a
 different path separator will not work, even if the underlying platform
 would otherwise accept it. This is to keep code using the Storage API
 portable between platforms and Storage implementations and simplify app
 code.

 Paths with relative directories ("." and "..") are forbidden by the Storage
 API.

 All valid UTF-8 strings (discounting the NULL terminator character and the
 '/' path separator) are usable for filenames, however, an underlying
 Storage implementation may not support particularly strange sequences and
 refuse to create files with those names, etc.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryVideo
*>
module sdl;


alias SDLStorageInterfaceClose = fn bool(void* userdata);
alias SDLStorageInterfaceReady = fn bool(void* userdata);
alias SDLStorageInterfaceEnumerate = fn bool(void* userdata, ZString path, SDLEnumerateDirectoryCallback callback, void* callback_userdata);
alias SDLStorageInterfaceInfo = fn bool(void* userdata, ZString path, SDLPathInfo* info);
alias SDLStorageInterfaceReadFile = fn bool(void* userdata, ZString path, void* destination, ulong length);
alias SDLStorageInterfaceWriteFile = fn bool(void* userdata, ZString path, void* source, ulong length);
alias SDLStorageInterfaceMkdir = fn bool(void* userdata, ZString path);
alias SDLStorageInterfaceRemove = fn bool(void* userdata, ZString path);
alias SDLStorageInterfaceRename = fn bool(void* userdata, ZString oldpath, ZString newpath);
alias SDLStorageInterfaceCopy = fn bool(void* userdata, ZString oldpath, ZString newpath);
alias SDLStorageInterfaceSpaceRemaining = fn ulong(void* userdata);

<*
 Function interface for SDL_Storage.
 This struct is available since SDL 3.2.0.

 Apps that want to supply a custom implementation of SDL_Storage will fill
 in all the functions in this struct, and then pass it to SDL_OpenStorage to
 create a custom SDL_Storage object.

 It is not usually necessary to do this; SDL provides standard
 implementations for many things you might expect to do with an SDL_Storage.

 This structure should be initialized using SDL_INIT_INTERFACE()
*>
struct SDLStorageInterface
{
    /* The version of this interface */
    uint version;

    /* Called when the storage is closed */
	SDLStorageInterfaceClose close;

    /* Optional, returns whether the storage is currently ready for access */
	SDLStorageInterfaceReady ready;

    /* Enumerate a directory, optional for write-only storage */
	SDLStorageInterfaceEnumerate enumerate;

    /* Get path information, optional for write-only storage */
	SDLStorageInterfaceInfo info;

    /* Read a file from storage, optional for write-only storage */
	SDLStorageInterfaceReadFile read_file;

    /* Write a file to storage, optional for read-only storage */
	SDLStorageInterfaceWriteFile write_file;

    /* Create a directory, optional for read-only storage */
	SDLStorageInterfaceMkdir mkdir;

    /* Remove a file or empty directory, optional for read-only storage */
	SDLStorageInterfaceRemove remove;

    /* Rename a path, optional for read-only storage */
	SDLStorageInterfaceRename rename;

    /* Copy a file, optional for read-only storage */
	SDLStorageInterfaceCopy copy;

    /* Get the space remaining, optional for read-only storage */
	SDLStorageInterfaceSpaceRemaining space_remaining;
}

/* Check the size of SDL_StorageInterface
 *
 * If this assert fails, either the compiler is padding to an unexpected size,
 * or the interface has been updated and this should be updated to match and
 * the code using this interface should be updated to handle the old version.
 */
$assert(
	((void*).sizeof == 4 && SDLStorageInterface.sizeof == 48) ||
	((void*).sizeof == 8 && SDLStorageInterface.sizeof == 96));

<*
 An abstract interface for filesystem access.
 This struct is available since SDL 3.2.0.

 This is an opaque datatype. One can create this object using standard SDL
 functions like SDL_OpenTitleStorage or SDL_OpenUserStorage, etc, or create
 an object with a custom implementation using SDL_OpenStorage.
*>
typedef SDLStorage = void;

<*
 Opens up a read-only container for the application's filesystem.
 This function is available since SDL 3.2.0.

 @param override : `a path to override the backend's default title root.`
 @param props : `a property list that may contain backend-specific information.`
 @return `a title storage container on success or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLStorage* open_title_storage(ZString override, SDLPropertiesID props) @extern("SDL_OpenTitleStorage");

<*
 Opens up a container for a user's unique read/write filesystem.
 This function is available since SDL 3.2.0.

 While title storage can generally be kept open throughout runtime, user
 storage should only be opened when the client is ready to read/write files.
 This allows the backend to properly batch file operations and flush them
 when the container has been closed; ensuring safe and optimal save I/O.

 @param org : `the name of your organization.`
 @param app : `the name of your application.`
 @param props : `a property list that may contain backend-specific information.`
 @return `a user storage container on success or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLStorage* open_user_storage(ZString org, ZString app, SDLPropertiesID props) @extern("SDL_OpenUserStorage");

<*
 Opens up a container for local filesystem storage.
 This function is available since SDL 3.2.0.

 This is provided for development and tools. Portable applications should
 use SDL_OpenTitleStorage() for access to game data and
 SDL_OpenUserStorage() for access to user data.

 @param path : `the base path prepended to all storage paths, or NULL for no
             base path.`
 @return `a filesystem storage container on success or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLStorage* open_file_storage(ZString path) @extern("SDL_OpenFileStorage");

<*
 Opens up a container using a client-provided storage interface.
 This function is available since SDL 3.2.0.

 Applications do not need to use this function unless they are providing
 their own SDL_Storage implementation. If you just need an SDL_Storage, you
 should use the built-in implementations in SDL, like SDL_OpenTitleStorage()
 or SDL_OpenUserStorage().

 This function makes a copy of `iface` and the caller does not need to keep
 it around after this call.

 @param iface : `the interface that implements this storage, initialized using
              SDL_INIT_INTERFACE().`
 @param userdata : `the pointer that will be passed to the interface functions.`
 @return `a storage container on success or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLStorage* open_storage(SDLStorageInterface* iface, void* userdata) @extern("SDL_OpenStorage");

<*
 Closes and frees a storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container to close.`
 @return `true if the container was freed with no errors, false otherwise;
          call SDL_GetError() for more information. Even if the function
          returns an error, the container data will be freed; the error is
          only for informational purposes.`
*>
extern fn bool SDLStorage.close(&storage) @extern("SDL_CloseStorage");

<*
 Checks if the storage container is ready to use.
 This function is available since SDL 3.2.0.

 This function should be called in regular intervals until it returns true -
 however, it is not recommended to spinwait on this call, as the backend may
 depend on a synchronous message loop. You might instead poll this in your
 game's main loop while processing events and drawing a loading screen.

 @param storage : `a storage container to query.`
 @return `true if the container is ready, false otherwise.`
*>
extern fn bool SDLStorage.ready(&storage) @extern("SDL_StorageReady");

<*
 Query the size of a file within a storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container to query.`
 @param path : `the relative path of the file to query.`
 @param length : `a pointer to be filled with the file's length.`
 @return `true if the file could be queried or false on failure; call
          SDL_GetError() for more information.`
*>
extern fn bool SDLStorage.get_file_size(&storage, ZString path, ulong* length) @extern("SDL_GetStorageFileSize");

<*
 Synchronously read a file from a storage container into a client-provided
 buffer.
 This function is available since SDL 3.2.0.

 The value of `length` must match the length of the file exactly; call
 SDL_GetStorageFileSize() to get this value. This behavior may be relaxed in
 a future release.

 @param storage : `a storage container to read from.`
 @param path : `the relative path of the file to read.`
 @param destination : `a client-provided buffer to read the file into.`
 @param length : `the length of the destination buffer.`
 @return `true if the file was read or false on failure; call SDL_GetError()
          for more information.`
*>
extern fn bool SDLStorage.read_file(&storage, ZString path, void* destination, ulong length) @extern("SDL_ReadStorageFile");

<*
 Synchronously write a file from client memory into a storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container to write to.`
 @param path : `the relative path of the file to write.`
 @param source : `a client-provided buffer to write from.`
 @param length : `the length of the source buffer.`
 @return `true if the file was written or false on failure; call
          SDL_GetError() for more information.`
*>
extern fn bool SDLStorage.write_file(&storage, ZString path, void* source, ulong length) @extern("SDL_WriteStorageFile");

<*
 Create a directory in a writable storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container.`
 @param path : `the path of the directory to create.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLStorage.create_directory(&storage, ZString path) @extern("SDL_CreateStorageDirectory");

<*
 Enumerate a directory in a storage container through a callback function.
 This function is available since SDL 3.2.0.

 This function provides every directory entry through an app-provided
 callback, called once for each directory entry, until all results have been
 provided or the callback returns either SDL_ENUM_SUCCESS or
 SDL_ENUM_FAILURE.

 This will return false if there was a system problem in general, or if a
 callback returns SDL_ENUM_FAILURE. A successful return means a callback
 returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
 were enumerated.

 If `path` is NULL, this is treated as a request to enumerate the root of
 the storage container's tree. An empty string also works for this.

 @param storage : `a storage container.`
 @param path : `the path of the directory to enumerate, or NULL for the root.`
 @param callback : `a function that is called for each entry in the directory.`
 @param userdata : `a pointer that is passed to 'callback'.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLStorage.enumerate_directory(&storage, ZString path, SDLEnumerateDirectoryCallback callback, void* userdata) @extern("SDL_EnumerateStorageDirectory");

<*
 Remove a file or an empty directory in a writable storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container.`
 @param path : `the path of the directory to enumerate.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLStorage.remove_path(&storage, ZString path) @extern("SDL_RemoveStoragePath");

<*
 Rename a file or directory in a writable storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container.`
 @param oldpath : `the old path.`
 @param newpath : `the new path.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLStorage.rename_path(&storage, ZString oldpath, ZString newpath) @extern("SDL_RenameStoragePath");

<*
 Copy a file in a writable storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container.`
 @param oldpath : `the old path.`
 @param newpath : `the new path.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLStorage.copy_file(&storage, ZString oldpath, ZString newpath) @extern("SDL_CopyStorageFile");

<*
 Get information about a filesystem path in a storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container.`
 @param path : `the path to query.`
 @param info : `a pointer filled in with information about the path, or NULL to
             check for the existence of a file.`
 @return `true on success or false if the file doesn't exist, or another
          failure; call SDL_GetError() for more information.`
*>
extern fn bool SDLStorage.get_path_info(&storage, ZString path, SDLPathInfo* info) @extern("SDL_GetStoragePathInfo");

<*
 Queries the remaining space in a storage container.
 This function is available since SDL 3.2.0.

 @param storage : `a storage container to query.`
 @return `the amount of remaining space, in bytes.`
*>
extern fn ulong SDLStorage.get_space_remaining(&storage) @extern("SDL_GetStorageSpaceRemaining");

<*
 Enumerate a directory tree, filtered by pattern, and return a list.
 This function is available since SDL 3.2.0.

 Files are filtered out if they don't match the string in `pattern`, which
 may contain wildcard characters `*` (match everything) and `?` (match one
 character). If pattern is NULL, no filtering is done and all results are
 returned. Subdirectories are permitted, and are specified with a path
 separator of '/'. Wildcard characters `*` and `?` never match a path
 separator.

 `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
 case-insensitive.

 The returned array is always NULL-terminated, for your iterating
 convenience, but if `count` is non-NULL, on return it will contain the
 number of items in the array, not counting the NULL terminator.

 If `path` is NULL, this is treated as a request to enumerate the root of
 the storage container's tree. An empty string also works for this.

 threadsafety: It is safe to call this function from any thread, assuming
               the `storage` object is thread-safe.

 @param storage : `a storage container.`
 @param path : `the path of the directory to enumerate, or NULL for the root.`
 @param pattern : `the pattern that files in the directory must match. Can be
                NULL.`
 @param flags : `'SDL_GLOB_*'' bitflags that affect this search.`
 @param count : `on return, will be set to the number of items in the returned
              array. Can be NULL.`
 @return `an array of strings on success or NULL on failure; call
          SDL_GetError() for more information. The caller should pass the
          returned pointer to SDL_free when done with it. This is a single
          allocation that should be freed with SDL_free() when it is no
          longer needed.`
*>
extern fn ZString* glob_storage_directory(SDLStorage* storage, ZString path, ZString pattern, SDLGlobFlags flags, CInt* count) @extern("SDL_GlobStorageDirectory");
